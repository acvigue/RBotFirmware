<html>
<head>

<style>
body {
  margin: 0;
  padding: 0;
  font-family: monospace;
  align-items: center;
  justify-content: center;
}

p {
    margin-top: 20px;
    text-align: center;
}

canvas {
  display: block;
  float: left;
  margin: 20px auto;
  background-color: white;
}

#tooltip {
  position: absolute;
  text-align: center;
  width: 100px;
  height: 12px;
  padding: 8px;
  margin-top: -20px;
  font: 10px sans-serif;
  background: #ddd;
  pointer-events: none;
}
#sand {
  display: block;
  float: left;
  margin: 20px auto;
  background-color: white;
  width: 600px;
  height: 600px;
}
.colourTableDiv {
    margin: 20px auto;
    padding: 10px;
    float:left;
}
.colourTableWhole {
    background: antiquewhite;
    padding: 10px;
}
.colourTable {
    
}
.colourStr {
    margin: 5px;
    width: 300px;
}
.selected {
    border: solid 2px red;
}
    .colourPatch {

    }
    .colourPatchDiv {
        width:10px;
        height:10px;
        background-color: #000000;
    }
</style>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
</head>
<body>
<p>Sand Table Sim</p>
<canvas id="canvas"></canvas>
<image id="sand" src="./sandTableImage.jpg"></image>
<div class="colourTableDiv">
    <div class="colourTableWhole">
        <p>Colour table</p>
        <table class="colourTable" id="colourTable">
            <tr><th>Idx</th><th>ColourStr</th></tr>
            <tr><td class="cidx">0</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">1</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">2</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">3</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">4</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">5</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">6</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">7</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">8</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">9</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
        </table>
    </div>
</div>
<div id="tooltip" style="display:inline"></div>
<script>

function rgb(r,g,b,a) {
    return [r,g,b,a];
}

class SandTableSim {
    constructor(options) {
        this.options = {
            cols: 600,
            rows: 600,
            sandLevelSize: 600,
            kernelSize: 20,
            ballPos: [300, 300],
            ballSize: 10,
            sandStartLevel: 5,
            maxSandLevel: 10,
            imgPixSqSize: 5
        };

        this.evalExpr = {
            t: 0,
            x: 300,
            y: 300,
            r: 0
        };

        this.sandColours = [
            // [ rgb(131, 86, 58), rgb(116, 74, 51), rgb(89, 57, 42) ],
            // [ rgb(160,115,78), rgb(136,90,60), rgb(159, 114, 77) ],
            // [ rgb(167,122,81), rgb(167,122,81), rgb(171, 130, 88) ],
            // [ rgb(140, 95, 63), rgb(132, 89, 59), rgb(139, 94, 61) ],
            // [ rgb(216,185,139), rgb(233,202,156), rgb(220,192,145)],
            // [ rgb(229,208,163), rgb(225,206,163), rgb(224, 202, 160) ],
            // [ rgb(234, 217, 182), rgb(231, 209, 166), rgb(207, 176, 132) ]
            // [rgb(144, 99, 68),rgb(140, 95, 65)],
            // [rgb(157, 115, 82),rgb(156, 115, 84)],
            // [rgb(159, 114, 74),rgb(159, 115, 73)],
            // [rgb(196, 164, 117),rgb(197, 160, 115),rgb(195, 158, 113)],
            // [rgb(207, 174, 131),rgb(213, 183, 138)],
            // [rgb(225, 202, 160),rgb(234, 212, 173),rgb(223, 199, 155)],
            // [rgb(229, 205, 162),rgb(231, 212, 172),rgb(232, 210, 169)],
            // [rgb(239, 221, 186),rgb(236, 218, 185),rgb(238, 221, 188)],
            // [rgb(239, 221, 186),rgb(236, 218, 185),rgb(238, 221, 188)],
            // [rgb(239, 221, 186),rgb(236, 218, 185),rgb(238, 221, 188)]

            // [rgb(146,105,75,255),rgb(147,106,76,255),rgb(141,100,69,255),rgb(144,103,72,255),rgb(157,116,84,255),rgb(143,102,70,255),rgb(145,104,72,255),rgb(158,117,85,255),rgb(152,112,77,255)],
            // [rgb(152,112,76,255),rgb(144,104,69,255),rgb(142,101,69,255),rgb(138,98,63,255),rgb(128,87,55,255),rgb(135,94,62,255),rgb(132,93,57,255),rgb(134,94,61,255),rgb(135,94,62,255)],
            // [rgb(167,130,87,255),rgb(166,128,88,255),rgb(169,130,91,255),rgb(171,134,92,255),rgb(156,118,79,255),rgb(175,136,97,255),rgb(158,120,81,255),rgb(142,102,66,255),rgb(140,100,64,255)],
            // [rgb(187,150,106,255),rgb(183,146,102,255),rgb(179,142,100,255),rgb(194,157,113,255),rgb(179,142,99,255),rgb(160,123,81,255),rgb(189,151,108,255),rgb(161,123,81,255),rgb(141,103,62,255)],
            // [rgb(194,157,112,255),rgb(196,158,113,255),rgb(186,145,101,255),rgb(188,151,106,255),rgb(191,152,110,255),rgb(171,129,89,255),rgb(172,135,91,255),rgb(161,122,81,255),rgb(161,118,83,255)],
            // [rgb(193,162,115,255),rgb(188,153,107,255),rgb(185,142,100,255),rgb(189,157,110,255),rgb(190,156,110,255),rgb(202,159,117,255),rgb(208,176,129,255),rgb(194,160,114,255),rgb(210,171,128,255)],
            // [rgb(205,171,126,255),rgb(198,164,119,255),rgb(193,158,113,255),rgb(205,168,124,255),rgb(188,151,107,255),rgb(184,146,102,255),rgb(193,155,111,255),rgb(189,148,106,255),rgb(184,143,101,255)],
            // [rgb(214,185,141,255),rgb(211,180,136,255),rgb(195,164,119,255),rgb(217,186,142,255),rgb(218,187,143,255),rgb(206,174,130,255),rgb(214,183,139,255),rgb(213,182,138,255),rgb(209,176,132,255)],
            // [rgb(226,202,161,255),rgb(225,203,162,255),rgb(221,202,159,255),rgb(226,203,161,255),rgb(225,203,162,255),rgb(225,206,164,255),rgb(232,209,169,255),rgb(228,206,167,255),rgb(222,203,161,255)],
            // [rgb(239,219,183,255),rgb(235,215,179,255),rgb(234,216,180,255),rgb(243,225,187,255),rgb(239,221,183,255),rgb(237,219,181,255),rgb(237,219,178,255),rgb(232,214,173,255),rgb(231,212,172,255)]

            // [rgb(126,82,52,255),rgb(127,84,54,255),rgb(132,88,58,255),rgb(132,88,59,255),rgb(151,107,78,255),rgb(127,84,55,255),rgb(132,89,60,255),rgb(130,87,58,255),rgb(138,95,66,255),rgb(133,90,61,255),rgb(133,92,62,255),rgb(145,104,74,255),rgb(131,90,60,255),rgb(126,85,55,255),rgb(132,91,61,255),rgb(127,86,56,255),rgb(138,97,67,255),rgb(134,93,63,255),rgb(124,83,53,255),rgb(130,89,59,255),rgb(134,93,64,255),rgb(128,87,58,255),rgb(132,91,62,255),rgb(128,87,59,255),rgb(121,80,52,255)],
            // [rgb(132,89,55,255),rgb(138,95,61,255),rgb(134,91,59,255),rgb(124,81,49,255),rgb(141,97,68,255),rgb(134,93,60,255),rgb(130,89,57,255),rgb(140,99,69,255),rgb(135,94,64,255),rgb(127,86,58,255),rgb(123,82,51,255),rgb(125,84,54,255),rgb(146,105,75,255),rgb(131,90,62,255),rgb(126,84,59,255),rgb(136,95,66,255),rgb(123,82,53,255),rgb(122,81,52,255),rgb(124,83,56,255),rgb(108,66,41,255),rgb(135,94,66,255),rgb(115,74,46,255),rgb(125,84,56,255),rgb(120,78,53,255),rgb(108,66,41,255)],
            // [rgb(139,96,60,255),rgb(135,92,56,255),rgb(135,93,57,255),rgb(136,93,59,255),rgb(141,98,64,255),rgb(149,108,74,255),rgb(136,96,61,255),rgb(138,98,64,255),rgb(132,89,55,255),rgb(139,96,64,255),rgb(143,102,71,255),rgb(138,97,66,255),rgb(139,98,67,255),rgb(133,91,61,255),rgb(126,85,54,255),rgb(136,95,65,255),rgb(134,93,63,255),rgb(135,94,65,255),rgb(131,90,60,255),rgb(129,88,59,255),rgb(124,83,55,255),rgb(123,82,54,255),rgb(127,86,58,255),rgb(130,89,60,255),rgb(125,84,56,255)],
            // [rgb(173,132,92,255),rgb(181,139,99,255),rgb(176,132,93,255),rgb(177,132,93,255),rgb(169,124,85,255),rgb(167,125,85,255),rgb(162,120,80,255),rgb(166,122,85,255),rgb(163,119,82,255),rgb(153,109,72,255),rgb(159,115,76,255),rgb(152,109,71,255),rgb(153,109,72,255),rgb(151,107,70,255),rgb(144,100,63,255),rgb(152,108,69,255),rgb(142,98,61,255),rgb(137,93,56,255),rgb(154,110,75,255),rgb(153,108,74,255),rgb(151,105,69,255),rgb(143,97,61,255),rgb(128,82,49,255),rgb(163,117,84,255),rgb(149,103,70,255)],

            [rgb(166,120,84,255),rgb(164,118,82,255),rgb(156,110,74,255),rgb(151,107,68,255),rgb(170,126,87,255),rgb(161,115,79,255),rgb(165,119,83,255),rgb(179,133,97,255),rgb(156,111,73,255),rgb(171,127,88,255),rgb(149,103,67,255),rgb(158,112,76,255),rgb(158,112,76,255),rgb(169,123,86,255),rgb(170,125,86,255),rgb(162,116,80,255),rgb(154,108,72,255),rgb(154,108,72,255),rgb(165,119,83,255),rgb(162,117,78,255),rgb(151,106,67,255),rgb(148,103,64,255),rgb(160,115,76,255),rgb(162,116,79,255),rgb(158,112,76,255)],
            [rgb(162,114,74,255),rgb(159,114,73,255),rgb(163,118,77,255),rgb(168,125,83,255),rgb(178,136,94,255),rgb(152,105,65,255),rgb(156,111,70,255),rgb(161,117,76,255),rgb(161,118,76,255),rgb(192,151,108,255),rgb(176,131,90,255),rgb(165,120,79,255),rgb(176,133,91,255),rgb(163,121,79,255),rgb(168,128,85,255),rgb(171,126,87,255),rgb(163,119,80,255),rgb(163,119,80,255),rgb(154,113,72,255),rgb(166,128,86,255),rgb(169,124,85,255),rgb(159,114,75,255),rgb(151,107,68,255),rgb(168,129,88,255),rgb(190,153,111,255)],
            [rgb(170,128,86,255),rgb(163,121,79,255),rgb(156,114,72,255),rgb(151,109,67,255),rgb(146,104,62,255),rgb(160,117,75,255),rgb(159,116,74,255),rgb(151,108,66,255),rgb(149,106,64,255),rgb(149,106,65,255),rgb(149,104,65,255),rgb(153,108,69,255),rgb(146,102,63,255),rgb(148,104,66,255),rgb(154,112,73,255),rgb(148,103,64,255),rgb(152,106,70,255),rgb(144,100,63,255),rgb(141,98,60,255),rgb(139,97,59,255),rgb(144,99,60,255),rgb(157,113,76,255),rgb(152,108,71,255),rgb(131,89,51,255),rgb(153,111,73,255)],
            [rgb(180,146,109,255),rgb(188,153,113,255),rgb(187,152,110,255),rgb(195,160,118,255),rgb(201,167,122,255),rgb(185,151,113,255),rgb(191,156,116,255),rgb(192,157,115,255),rgb(194,159,117,255),rgb(194,160,116,255),rgb(192,158,120,255),rgb(198,163,123,255),rgb(200,165,123,255),rgb(205,171,129,255),rgb(200,167,123,255),rgb(195,161,123,255),rgb(197,162,120,255),rgb(199,164,122,255),rgb(212,179,136,255),rgb(206,173,128,255),rgb(190,157,116,255),rgb(197,164,121,255),rgb(201,168,125,255),rgb(206,173,130,255),rgb(206,174,129,255)],
            [rgb(201,164,122,255),rgb(195,157,116,255),rgb(180,141,100,255),rgb(178,138,97,255),rgb(165,123,83,255),rgb(194,157,115,255),rgb(186,148,106,255),rgb(178,139,98,255),rgb(165,126,85,255),rgb(155,116,75,255),rgb(188,151,109,255),rgb(181,143,102,255),rgb(166,128,86,255),rgb(169,130,89,255),rgb(158,119,78,255),rgb(196,160,117,255),rgb(184,147,104,255),rgb(156,119,76,255),rgb(145,106,64,255),rgb(139,100,58,255),rgb(188,154,109,255),rgb(170,134,89,255),rgb(154,117,73,255),rgb(146,109,65,255),rgb(133,95,52,255)],
            [rgb(209,176,131,255),rgb(209,176,131,255),rgb(208,175,130,255),rgb(210,177,132,255),rgb(207,173,128,255),rgb(214,181,136,255),rgb(210,176,131,255),rgb(207,173,128,255),rgb(204,170,125,255),rgb(203,166,122,255),rgb(208,174,129,255),rgb(208,174,129,255),rgb(207,171,127,255),rgb(202,166,121,255),rgb(197,160,116,255),rgb(209,175,130,255),rgb(204,170,125,255),rgb(203,166,122,255),rgb(207,170,126,255),rgb(192,155,111,255),rgb(201,166,121,255),rgb(204,167,123,255),rgb(201,164,120,255),rgb(201,162,119,255),rgb(201,162,119,255)],
            [rgb(213,180,135,255),rgb(208,176,129,255),rgb(207,175,128,255),rgb(203,170,125,255),rgb(211,178,133,255),rgb(207,176,130,255),rgb(209,178,131,255),rgb(209,178,131,255),rgb(205,172,127,255),rgb(208,175,130,255),rgb(207,176,130,255),rgb(208,177,130,255),rgb(211,180,133,255),rgb(215,182,137,255),rgb(213,180,135,255),rgb(209,178,132,255),rgb(210,179,132,255),rgb(210,179,132,255),rgb(213,180,135,255),rgb(210,177,132,255),rgb(211,180,134,255),rgb(213,182,135,255),rgb(210,179,132,255),rgb(215,182,137,255),rgb(208,175,130,255)],
            [rgb(206,177,133,255),rgb(208,181,136,255),rgb(213,186,141,255),rgb(211,182,138,255),rgb(201,173,126,255),rgb(204,175,131,255),rgb(206,178,133,255),rgb(210,183,138,255),rgb(211,182,138,255),rgb(210,182,135,255),rgb(203,174,130,255),rgb(210,183,138,255),rgb(210,183,138,255),rgb(206,177,133,255),rgb(206,178,131,255),rgb(209,180,136,255),rgb(211,184,139,255),rgb(214,187,142,255),rgb(212,183,139,255),rgb(211,183,136,255),rgb(206,177,133,255),rgb(216,189,144,255),rgb(221,194,149,255),rgb(216,187,143,255),rgb(207,179,132,255)],
            [rgb(215,187,147,255),rgb(217,189,149,255),rgb(216,188,148,255),rgb(219,191,151,255),rgb(219,191,151,255),rgb(215,187,147,255),rgb(219,191,151,255),rgb(219,191,151,255),rgb(220,192,152,255),rgb(220,192,152,255),rgb(214,186,147,255),rgb(217,189,149,255),rgb(220,192,152,255),rgb(221,193,153,255),rgb(219,192,149,255),rgb(216,188,149,255),rgb(216,188,148,255),rgb(217,189,149,255),rgb(218,190,150,255),rgb(218,191,148,255),rgb(219,191,152,255),rgb(219,191,151,255),rgb(218,190,150,255),rgb(215,187,147,255),rgb(217,190,147,255)],
            [rgb(230,209,170,255),rgb(232,210,171,255),rgb(225,203,163,255),rgb(231,209,168,255),rgb(233,210,169,255),rgb(229,209,167,255),rgb(230,208,167,255),rgb(229,207,165,255),rgb(226,203,161,255),rgb(227,204,162,255),rgb(227,206,164,255),rgb(214,193,150,255),rgb(220,198,154,255),rgb(222,199,155,255),rgb(225,202,158,255),rgb(228,206,163,255),rgb(217,196,152,255),rgb(222,200,155,255),rgb(225,202,157,255),rgb(227,203,158,255),rgb(227,203,159,255),rgb(226,204,159,255),rgb(223,202,156,255),rgb(233,210,163,255),rgb(227,203,157,255)]

        ]

        this.options = Object.assign(this.options, options);

        this.sandToPixelScaleFactor = this.sandColours.length / this.options.maxSandLevel;

        this.createSandLevel();
        this.createKernel();
        this.initCanvas();
        this.initTable();
        this.onResize();
        this.showPicture();
        this.addEventListener();
        this.showSand();
        this.animate();
    }

    createSandLevel() {
        let sandLevelSize = this.options.sandLevelSize;
        // Generate a 2D array of distances from the centre of the kernel
        this.sandLevel = new Array(sandLevelSize);
        for (let i = 0; i < sandLevelSize; i++)
        {
            this.sandLevel[i] = new Array(sandLevelSize);
            for (let j = 0; j < sandLevelSize; j++)
            {
                this.sandLevel[i][j] = this.options.sandStartLevel;
                // console.log(i + "," + j + "," + this.kernel[i][j]);
            }
        }
    }

    createKernel() {
        let kernelSize = this.options.kernelSize;
        // Generate a 2D array of distances from the centre of the kernel
        let kernelDists = new Array(kernelSize);
        for (let i = 0; i < kernelSize; i++)
        {
            kernelDists[i] = new Array(kernelSize);
            for (let j = 0; j < kernelSize; j++)
            {
                let distFromCtr = Math.round(Math.sqrt((Math.pow(i - kernelSize/2, 2)) + (Math.pow(j - kernelSize/2, 2))));
                kernelDists[i][j] = distFromCtr;
                // console.log(i + "," + j + "," + this.kernel[i][j]);
            }
        }
        // Create a series of lists of pixels at each distance from kernel centre
        this.kernelLists = new Array(kernelSize/2);
        for (let k = 0; k < kernelSize/2; k++)
            this.kernelLists[k] = [];
        for (let i = 0; i < kernelSize; i++)
        {
            for (let j = 0; j < kernelSize; j++)
            {
                if (kernelDists[i][j] < kernelSize/2)
                    this.kernelLists[kernelDists[i][j]].push([i,j]);
            }
        }
        for (let k = 0; k < kernelSize/2; k++)
            console.log("Ks " + this.kernelLists[k].length);
        // Sand amount to move at each ring of distance - this is like a threshold level (curvature of ball bearing)
        this.kernelMoveThreshold = new Array(kernelSize/2);
        for (let k = 0; k < kernelSize/2; k++)
        {
            this.kernelMoveThreshold[k] = (this.options.ballSize/2) * Math.sin(k * Math.PI / kernelSize);
            console.log("moveThreshold " + k + " = " + this.kernelMoveThreshold[k]);
        }    

    }

    initCanvas() {
        this.canvas = document.querySelector('canvas');
        this.ctx = this.canvas.getContext('2d');
        //this.setSize();
    }

    initTable() {
        let i = 0;
        let that = this;
        $(".colourStr").each(function() {
            let colrArry = that.sandColours[i];
            let pixDataStr = that.toRGBArrayStr(colrArry);
            $(this).val(pixDataStr);
            $(this).parent().parent().find(".colourPatchDiv").css('background-color', that.toRGBStr(colrArry[0]));
            let cidx = parseInt($(this).parent().parent().find(".cidx").text());
            that.sandColours[cidx] = colrArry;
            i++;
        });
    }
    setSize() {
        this.canvas.width = this.options.cols;
        this.canvas.height = this.options.rows;
    }

    onResize() {
        this.setSize();

        // // noise.seed(Math.random());

        // this.options.cols = Math.floor(this.canvas.width / this.options.scl) + 1;
        // this.options.rows = Math.floor(this.canvas.height / this.options.scl) + 1;
     
        // this.initField();
        // this.initParticles();
    }

    showPicture() {
        // var image = new Image();
        // image.src = "29129023-white-sand-detail-texture-background-top-view-Stock-Photo.jpg";
        // image.onload = function() {
        //     var canvas = document.querySelector('canvas');
        //     var ctx = canvas.getContext('2d');
        //     ctx.drawImage(image, 0, 0); // (image, x, y)
        // }
        // this.ctx.fillStyle = 'rgba(197, 160, 115,0.9)';
        // this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);
    }

    addEventListener() {
        window.addEventListener('resize', () => this.onResize());
        this.canvas.addEventListener('mousemove', (e) => this.mousemove(e));
        this.canvas.addEventListener('mouseover', (e) => this.mouseover(e));
        this.canvas.addEventListener('mouseout', (e) => this.mouseout(e));
        let sandImg = document.getElementById("sand");
        sandImg.addEventListener('click', (e) => this.mouseclicksand(e));
        $('.colourStr').click(function() {
            $('.selected').removeClass('selected');
            $(this).addClass('selected');
        });
    }

    // animate() {
    //     this.ctx.fillStyle = 'rgba(197, 160, 115,0.9)';
    //     this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);
    //     //ctx.clearRect(0,0,canvas.width, canvas.height);
    //
    //     // requestAnimationFrame(() => this.animate());
    //     // this.calculateField();
    //
    //     this.options.zoff += this.options.inc;
    //
    //     //this.drawField();
    //     this.drawParticles();
    // }

    getAngleToMotion(pt, kSize, moveAngle) {
        let diffAngle = Math.atan2(kSize/2 - pt[1], pt[0] - kSize/2) - moveAngle;
        // Correct wrapping around circle
        diffAngle = (diffAngle + Math.PI) % (2 * Math.PI);
        if (diffAngle < 0)
            diffAngle += 2 * Math.PI;
        diffAngle -= Math.PI;
        return diffAngle;
    }

    dumpSand() {
        console.log("Sand!");
        let sandLevelSize = this.options.sandLevelSize;
        for (let i = 0; i < sandLevelSize; i++)
        {
            let sss = "";
            for (let j = 0; j < sandLevelSize; j++)
            {
                sss += ((j === 0) ? "" : ",") + this.sandLevel[i][j];
                // console.log(i + "," + j + "," + this.kernel[i][j]);
            }
            console.log(sss);
        }

    }

    moveSand(moveAngleACWFromEast) {
        // Work out from the centre of the ball bearing moving "sand"
        let kSize = this.options.kernelSize;
        let sandAccumulator = 0;
        for (let k = 0; k < this.kernelLists.length-1; k++) {
            let sourceRing = this.kernelLists[k];
            // Go around this ring moving "sand" outwards to a degree dependent on the angle of motion
            for (let s = 0; s < sourceRing.length; s++) {
                let sourceKernelPt = sourceRing[s];
                let sourceSandPt = [Math.floor(sourceKernelPt[0] + this.options.ballPos[0] - this.options.kernelSize / 2), Math.floor(sourceKernelPt[1] + this.options.ballPos[1] - this.options.kernelSize / 2)];
                if (sourceSandPt[0] < 0 || sourceSandPt[0] >= this.options.sandLevelSize)
                    continue;
                if (sourceSandPt[1] < 0 || sourceSandPt[1] >= this.options.sandLevelSize)
                    continue;
                let angleToMotion = this.getAngleToMotion(sourceKernelPt, kSize, moveAngleACWFromEast);
                // console.log("Sourceang " + angleToMotion + " moveAngle " + moveAngleACWFromEast);
                // Only move sand in front of ball bearing movement
                if (angleToMotion > -Math.PI / 2 && angleToMotion < Math.PI / 2) {
                    // Move all the sand above the threshold
                    let sandToMove = this.sandLevel[sourceSandPt[0]][sourceSandPt[1]] - this.kernelMoveThreshold[k];
                    if (sandToMove < 0)
                        sandToMove = 0;
                    // console.log("SandQty at " + sourceSandPt[0] + ", " + sourceSandPt[1] + " ring " + k + " = " + this.sandLevel[sourceSandPt[0]][sourceSandPt[1]] + " => " + this.kernelMoveThreshold[k]);
                    // (" + this.kernelMoveThreshold[k] + ") = " + sandToMove + " total " + this.sandLevel[sourceSandPt[0]][sourceSandPt[1]]);
                    this.sandLevel[sourceSandPt[0]][sourceSandPt[1]] -= sandToMove;
                    // Add sand acculumated from spill-over
                    // console.log("SandToMove = " + sandToMove + ", sandAccumulator = " + sandAccumulator);
                    sandToMove += sandAccumulator;
                    sandAccumulator = 0;
                    // Make a list of the points on the next ring within similar angles to distribute sand to
                    let destRing = this.kernelLists[k + 1];
                    let destPtList = [];
                    for (let t = 0; t < destRing.length; t++) {
                        let destKernelPt = destRing[t];
                        let destSandPt = [Math.floor(destKernelPt[0] + this.options.ballPos[0] - this.options.kernelSize / 2), Math.floor(destKernelPt[1] + this.options.ballPos[1] - this.options.kernelSize / 2)];
                        if (destSandPt[0] < 0 || destSandPt[0] >= this.options.sandLevelSize)
                            continue;
                        if (destSandPt[1] < 0 || destSandPt[1] >= this.options.sandLevelSize)
                            continue;
                        let destAngleToMotion = this.getAngleToMotion(destKernelPt, kSize, moveAngleACWFromEast);
                        let diffAngle2 = destAngleToMotion - angleToMotion;
                        diffAngle2 += (diffAngle2 > 180) ? -360 : (diffAngle2 < -180) ? 360 : 0;
                        diffAngle2 = Math.abs(diffAngle2);
                        if (diffAngle2 < 2 * Math.PI / sourceRing.length) {
                            // console.log("Dest at k+1 " + k + " ang2 " + diffAngle2 + " pt " + destSandPt[0] + "," + destSandPt[1]);
                            destPtList.push(destSandPt);
                        }
                    }
                    // Now actually distribute
                    for (let i = 0; i < destPtList.length; i++) {
                        this.sandLevel[destPtList[i][0]][destPtList[i][1]] += sandToMove / destPtList.length;
                        // If the sand level is above max then distribute to the next ring outwards using the sandAccumulator
                        if (this.sandLevel[destPtList[i][0]][destPtList[i][1]] >= this.options.maxSandLevel) {
                            sandAccumulator += this.sandLevel[destPtList[i][0]][destPtList[i][1]] - this.options.maxSandLevel + 0.01;
                            this.sandLevel[destPtList[i][0]][destPtList[i][1]] = this.options.maxSandLevel - 0.01;
                        }
                        // console.log("Dest at " + destPtList[i][0] + "," + destPtList[i][1] + " = " + this.sandLevel[destPtList[i][0]][destPtList[i][1]]);
                    }
                }
            }
        }

        // console.log("Final sandAccumulator" + sandAccumulator);

        // Spread the left-over sand
        if (sandAccumulator > 0) {
            let tlx = Math.floor(this.options.ballPos[0] - this.options.kernelSize / 2);
            if (tlx < 0)
                tlx = 0;
            let tly = Math.floor(this.options.ballPos[1] - this.options.kernelSize / 2);
            if (tly < 0)
                tly = 0;
            let spreadX = Math.floor(tlx + this.options.kernelSize);
            if (spreadX >= this.options.sandLevelSize)
                spreadX = this.options.sandLevelSize - 1;
            let spreadY = Math.floor(tly + this.options.kernelSize);
            if (spreadY >= this.options.sandLevelSize)
                spreadY = this.options.sandLevelSize - 1;
            let sandToAdd = sandAccumulator / ((spreadX-tlx)*(spreadY-tly));
            for (var x = tlx; x < spreadX; x++)
                for (var y = tly; y < spreadY; y++)
                {
                    this.sandLevel[x][y] += sandToAdd;
                }
        }

        // this.tallySand();



            // console.log("Total sand qty " + sandQuantity);
            // // Now calculate where to move this "sand"
            // let sandMoveFactors = [];
            // let moveMassSum = 0;
            // for (let s = 0; s < this.kernelLists[k+1].length; s++)
            // {
            //     let kernelDestPt = this.kernelLists[k+1][s];
            //     let diffAngle = getAngleToPt(kernelDestPt);
            //     // Calculate sum - only move sand in front of us
            //     let diffFactor = 0;
            //     if (diffAngle < Math.PI/2)
            //     {
            //         diffFactor = cos(diffAngle);
            //         moveMassSum += diffFactor;
            //     }
            //     sandMoveFactors.push([diffFactor, kernelDestPt[0], kernelDestPt[1]]);
            //     console.log("MoveFactors " + s + " fact = " + diffFactor + " ang = " + (diffAngle * 180 / Math.PI) + " y " +
            //                  (kSize/2 - kernelDestPt[1]) + " x " + (kernelDestPt[0] - kSize/2));
            // }
            // // Move the sand
            // for (let s = 0; s < this.kernelLists[k+1].length; s++)
            // {
            //     let kernelDestPt = this.kernelLists[k+1][s];
            //     this.sandLevel[kernelDestPt[0]][kernelDestPt[1]] += sandQuantity * sandMoveFactors[s] / moveMassSum;

                // Move the sand
                // this.sandLevel[this.kernelLists[k][0]][this.kernelLists[k][1]] * this.kernelMoveFactor[k];
                // sandQuantity += sandToMove;
                // this.sandLevel[this.kernelLists[k][0]][this.kernelLists[k][1]] -= sandToMove;



        // this.dumpSand();

        // var canvas = document.querySelector('canvas');
        // var ctx = canvas.getContext('2d');
        // var tlx = this.options.ballPos[0] - this.options.kernelSize/2;
        // var tly = this.options.ballPos[1] - this.options.kernelSize/2;
        // var sqAroundBall = ctx.getImageData(tlx, tly, 
        //                 this.options.kernelSize,
        //                 this.options.kernelSize);
        // var data = sqAroundBall.data;
        // var colors = [];
        // console.log("Width " + sqAroundBall.width);
        // // Image data from centre of ball

        // // let centreVal = ctx.getImageData(this.options.ballPos[0], this.options.ballPos[1], 1, 1);

        // for(var i = 0, j = 0, k = 0, loop = data.length; i < loop; i += 4) {
        //     let hsl = this.rgbToHsl(data[i], data[i+1], data[i+2]);
        //     hsl[2] *= this.kernel[j][k];
        //     let rgb = this.hslToRgb(hsl[0], hsl[1], hsl[2]);
        //     data[i] = rgb[0];
        //     data[i+1] = rgb[1];
        //     data[i+2] = rgb[2];
        //     j += 1;
        //     if (j >= sqAroundBall.width)
        //     {
        //         k += 1;
        //         j = 0;
        //     }
        // }
        // ctx.putImageData(sqAroundBall,tlx, tly);

        // Redraw the image around the ball position
        this.recreateSandSquareImage(this.options.ballPos, this.options.kernelSize);
    }

    randInt(min, max) {
        return Math.floor(Math.random() * (max - min) ) + min;
    }

    colourIndex(sandLevel) {
        if (sandLevel === undefined)
            return [0,0,0,0];
        let colourIdx = Math.floor(sandLevel * this.sandToPixelScaleFactor);
        if (colourIdx < 0)
            colourIdx = 0;
        if (colourIdx > this.sandColours.length-1)
            colourIdx = this.sandColours.length-1;
        return colourIdx;
    }

    pixelLookup(sandLevel) {
        let sandRange = this.sandColours[this.colourIndex(sandLevel)];
        let pixColr = sandRange[this.randInt(0,sandRange.length)];
        return pixColr;
    }

    recreateSandSquareImage(changePos, changeSize) {
        var canvas = document.querySelector('canvas');
        var ctx = canvas.getContext('2d');
        var chgTLX = Math.floor(changePos[0]-changeSize/2);
        if (chgTLX < 0)
            chgTLX = 0;
        var chgTLY = Math.floor(changePos[1]-changeSize/2);
        if (chgTLY < 0)
            chgTLY = 0;
        var chgSq = ctx.getImageData(chgTLX, chgTLY,
                        changeSize,
                        changeSize);
        let k = 0;
        for (let i = 0; i < changeSize; i++)
        {
            if (i + chgTLY >= this.options.sandLevelSize)
                break;
            for (let j = 0; j < changeSize; j++)
            {
                if (j + chgTLX >= this.options.sandLevelSize)
                    break;
                // fullSqData[k] = this.sandLevel[j][i];
                // fullSqData[k+1] = this.sandLevel[j][i];
                // fullSqData[k+2] = this.sandLevel[j][i];
                let pixVal = this.pixelLookup(this.sandLevel[j+chgTLX][i+chgTLY]);
                chgSq.data[k] = pixVal[0];
                chgSq.data[k+1] = pixVal[1];
                chgSq.data[k+2] = pixVal[2];
                chgSq.data[k+3] = pixVal[3];
                // if (fullSqData[k]>200 && fullSqData[k+1]>200 && fullSqData[k+2]>200)
                //     debugger;
                k+=4;
            }
        }
        ctx.putImageData(chgSq,chgTLX,chgTLY);
    }

    tallySand() {
        var sandTot = 0;
        var histBars = [];
        let sandBars = [];
        let maxLev = this.sandLevel[0][0];
        for (var i = 0; i < this.sandColours.length; i++) {
            histBars.push(0);
        }
        for (var i = 0; i < this.options.maxSandLevel; i++) {
            sandBars.push(0);
        }
        let sandLevelSize = this.options.sandLevelSize;
        for (let i = 0; i < sandLevelSize; i++) {
            for (let j = 0; j < sandLevelSize; j++) {
                // Debug
                if (maxLev < this.sandLevel[j][i])
                    maxLev = this.sandLevel[j][i];
                histBars[this.colourIndex(this.sandLevel[j][i])]++;
                sandBars[Math.floor(this.sandLevel[j][i])]++;
                sandTot += this.sandLevel[j][i];
            }
        }
        console.log("TotalSand " + sandTot + ", MaxLev " + maxLev);

        let barSum = 0;
        for (var i = 0; i < histBars.length; i++) {
            console.log(i + " colr " + histBars[i]);
            barSum += histBars[i];
        }
        console.log("ColrSum = " + barSum);

        let sandSum = 0;
        for (var i = 0; i < sandBars.length; i++) {
            console.log(i + " sand " + sandBars[i]);
            sandSum += sandBars[i];
        }
        console.log("SandSum = " + barSum);

    }
    showSand() {
        var canvas = document.querySelector('canvas');
        var ctx = canvas.getContext('2d');
        var fullSq = ctx.getImageData(0, 0, 
                        this.options.sandLevelSize,
                        this.options.sandLevelSize);
        let sandLevelSize = this.options.sandLevelSize;
        let fullSqData = fullSq.data;
        let k = 0;
        for (let i = 0; i < sandLevelSize; i++)
        {
            for (let j = 0; j < sandLevelSize; j++)
            {
                // fullSqData[k] = this.sandLevel[j][i];
                // fullSqData[k+1] = this.sandLevel[j][i];
                // fullSqData[k+2] = this.sandLevel[j][i];
                let pixVal = this.pixelLookup(this.sandLevel[j][i]);
                fullSqData[k] = pixVal[0];
                fullSqData[k+1] = pixVal[1];
                fullSqData[k+2] = pixVal[2];
                fullSqData[k+3] = pixVal[3];
                // if (fullSqData[k]>200 && fullSqData[k+1]>200 && fullSqData[k+2]>200)
                //     debugger;
                k+=4;
            }
        }
        ctx.putImageData(fullSq,0,0);

        // var tlx = this.options.ballPos[0] - this.options.kernelSize/2;
        // var tly = this.options.ballPos[1] - this.options.kernelSize/2;
        // var sqAroundBall = ctx.getImageData(tlx, tly, 
        //                 this.options.kernelSize,
        //                 this.options.kernelSize);
        // var data = sqAroundBall.data;
        // var colors = [];
        // console.log("Width " + sqAroundBall.width);
        // // Image data from centre of ball

        // // let centreVal = ctx.getImageData(this.options.ballPos[0], this.options.ballPos[1], 1, 1);

        // for(var i = 0, j = 0, k = 0, loop = data.length; i < loop; i += 4) {
        //     let hsl = this.rgbToHsl(data[i], data[i+1], data[i+2]);
        //     hsl[2] *= this.kernel[j][k];
        //     let rgb = this.hslToRgb(hsl[0], hsl[1], hsl[2]);
        //     data[i] = rgb[0];
        //     data[i+1] = rgb[1];
        //     data[i+2] = rgb[2];
        //     j += 1;
        //     if (j >= sqAroundBall.width)
        //     {
        //         k += 1;
        //         j = 0;
        //     }
        // }
        // ctx.putImageData(sqAroundBall,tlx, tly);
    }

    toRGBArrayStr(arr) {
        let pixStr = "";
        for (var i = 0; i < arr.length; i++)
            pixStr += ((pixStr.length === 0) ? "" : ",") + this.toRGBStr(arr[i]);
        return "[" + pixStr + "]";
    }

    toRGBStr(pixData) {
         return "rgb(" + pixData[0] + "," + pixData[1] + "," + pixData[2] + "," + pixData[3] + ")";
    }
    mousemove(event) {
        
        let canvasOff = this.canvas.getBoundingClientRect();

        let imgX = Math.floor(event.clientX - canvasOff.left);
        let imgY = Math.floor(event.clientY - canvasOff.top);

        let mouseX = event.clientX;
        let mouseY = event.clientY;

        var fullSq = this.ctx.getImageData(0, 0, 
                        this.options.sandLevelSize,
                        this.options.sandLevelSize);

        var tooltip = document.querySelector('#tooltip');

        let pixIdx = imgX * 4 + this.options.sandLevelSize * imgY * 4;
        tooltip.innerHTML = this.sandLevel[imgX][imgY].toFixed(2) + " (" + fullSq.data[pixIdx] + ", " + fullSq.data[pixIdx+1] + ", " + fullSq.data[pixIdx+2] + ")";
        tooltip.style.left = (mouseX-14) + "px";
        tooltip.style.top = (mouseY+12) + "px";

        // let ballAngle = Math.atan2(this.options.ballPos[1] - ballY, ballX - this.options.ballPos[0]);
        // if (this.options.ballPos[0] === ballX && this.options.ballPos[1] === ballY)
        //     return;
        // this.options.ballPos[0] = ballX;
        // this.options.ballPos[1] = ballY;
        // this.moveSand(ballAngle);
        // this.showSand();

        // console.log(x + " " + y);
        //         this.ctx.fillStyle = 'rgba(240,240,240,0.9)';
        // this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);

        // this.options.zoff += this.options.inc;
        // drawParticles();
        // requestAnimationFrame(() => this.animate());
    }

    mouseover(event) {
        var canvas = document.querySelector('#tooltip');
        canvas.setAttribute("style","display:inline");
    }

    mouseout(event) {
        var canvas = document.querySelector('#tooltip');
        canvas.setAttribute("style","display:none");
    }

    getImagePixels(pixPos, sqSize) {
        var img = document.getElementById('sand');
        var memCanvas = document.createElement('canvas');
        memCanvas.width = img.width;
        memCanvas.height = img.height;
        memCanvas.getContext('2d').drawImage(img, 0, 0, img.width, img.height);
        var pixelData = memCanvas.getContext('2d').getImageData(pixPos[0]-Math.floor(sqSize/2), pixPos[1]-Math.floor(sqSize/2), sqSize, sqSize).data;
        console.log(pixPos[0] + ", " + pixPos[1] + " = ", pixelData);
        return pixelData;
    }

    mouseclicksand(event) {

        var img = document.querySelector('#sand');
        let imgOff = img.getBoundingClientRect();

        let imgX = Math.floor(event.clientX - imgOff.left);
        let imgY = Math.floor(event.clientY - imgOff.top);

        console.log("ClickSand " + imgX + ", " + imgY);

        let pixData = this.getImagePixels([imgX, imgY], this.options.imgPixSqSize);
        let colrArry = [];
        for (var i = 0; i < this.options.imgPixSqSize * this.options.imgPixSqSize * 4; i+=4)
            colrArry.push([pixData[i], pixData[i+1], pixData[i+2], pixData[i+3]]);
        let pixDataStr = this.toRGBArrayStr(colrArry);
        let onePixStr = this.toRGBStr(colrArry[0]);
        // var fullSq = this.ctx.getImageData(0, 0,
        //                 this.options.sandLevelSize,
        //                 this.options.sandLevelSize);


        let elStr = $('.selected');
        let that = this;
        elStr.each(function() {
            $(this).val(pixDataStr);
            $(this).parent().parent().find(".colourPatchDiv").css('background-color', onePixStr);
            let cidx = parseInt($(this).parent().parent().find(".cidx").text());
            that.sandColours[cidx] = colrArry;
        });

        this.showSand();
    }



    moveStep() {
        let canvasOff = canvas.getBoundingClientRect();

        // let ballX = this.options.sandLevelSize/2 + (this.options.sandLevelSize / 2 - 20 - this.evalExpr.r) * Math.sin(this.evalExpr.t);
        // let ballY = this.options.sandLevelSize/2 + (this.options.sandLevelSize / 2 - 20 - this.evalExpr.r) * Math.cos(this.evalExpr.t);
        // this.evalExpr.t += 0.01;
        // this.evalExpr.r += 0.01;
        // if (this.evalExpr.t > 600)
        //     this.evalExpr.t = 0;
        let t = this.evalExpr.t;

        let ballX = Math.sin(t/20) * (270 - t/10) * (1 + Math.sin(t*1.03)*0.05);
        let ballY = Math.cos(t/20) * (270 - t/10) * (1 + Math.sin(t*1.03)*0.05);
        this.evalExpr.t += 0.1;
        if (this.evalExpr.t > 100000)
            this.evalExpr.t = 0;
        ballX = this.options.sandLevelSize/2 + ballX;
        ballY = this.options.sandLevelSize/2 + ballY;

        let ballAngle = Math.atan2(this.options.ballPos[1] - ballY, ballX - this.options.ballPos[0]);
        this.options.ballPos[0] = ballX;
        this.options.ballPos[1] = ballY;
        this.moveSand(ballAngle);
    }

    animate() {
        for (let i = 0; i < 100; i++)
            this.moveStep();
        //this.showSand();
        requestAnimationFrame(() => this.animate());
    }


    /**
    * http://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
    * SOURCE: http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
    * Converts an HSL color value to RGB. Conversion formula
    * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
    * Assumes h, s, and l are contained in the set [0, 1] and
    * returns r, g, and b in the set [0, 255].
    *
    * @param   Number  h       The hue
    * @param   Number  s       The saturation
    * @param   Number  l       The lightness
    * @return  Array           The RGB representation
    */
    hslToRgb(h, s, l){
        var r, g, b;

        if (s == 0) {
            r = g = b = l; // achromatic
        } else {
          var hue2rgb = function hue2rgb(p, q, t){
            if(t < 0) t += 1;
            if(t > 1) t -= 1;
            if(t < 1/6) return p + (q - p) * 6 * t;
            if(t < 1/2) return q;
            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          }

          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }

        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
      }
      
    /**
    * http://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
    * SOURCE: http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c  
    * Converts an RGB color value to HSL. Conversion formula
    * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
    * Assumes r, g, and b are contained in the set [0, 255] and
    * returns h, s, and l in the set [0, 1].
    *
    * @param   Number  r       The red color value
    * @param   Number  g       The green color value
    * @param   Number  b       The blue color value
    * @return  Array           The HSL representation
    */
    rgbToHsl(r, g, b){
        r /= 255, g /= 255, b /= 255;
        var max = Math.max(r, g, b), min = Math.min(r, g, b);
        var h, s, l = (max + min) / 2;

        if (max == min) {
            h = s = 0; // achromatic
        } else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch(max){
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }

        return [h, s, l];
    }
  
}

// function handleMouseMove(event) {
//     var dot, eventDoc, doc, body, pageX, pageY;

//     event = event || window.event; // IE-ism

//     let x = event.pageX;
//     let y = event.pageY;

//     console.log(x + " " + y);
// }

let sandTableSim = new SandTableSim();

</script>
</body>
</html>
