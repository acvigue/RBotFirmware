<html>
<head>

<style>
body {
  margin: 0;
  padding: 0;
  font-family: monospace;
  align-items: center;
  justify-content: center;
}

p {
    margin-top: 20px;
    text-align: center;
}

canvas {
  display: block;
  float: left;
  margin: 20px auto;
  background-color: white;
}

#tooltip {
  position: absolute;
  text-align: center;
  width: 100px;
  height: 12px;
  padding: 8px;
  margin-top: -20px;
  font: 10px sans-serif;
  background: #ddd;
  pointer-events: none;
}
#table-canvas {
    width: auto;
    height: auto;
    object-fit: contain;
}
#sand {
  display: block;
  float: left;
  margin: 20px auto;
  background-color: white;
  width: 700px;
  height: 700px;
}
.colourTableDiv {
    margin: 20px auto;
    padding: 10px;
    float:left;
}
.colourTableWhole {
    background: antiquewhite;
    padding: 10px;
}
.colourTable {
    
}
.colourStr {
    margin: 5px;
    width: 300px;
}
.selected {
    border: solid 2px red;
}
    .colourPatch {

    }
    .colourPatchDiv {
        width:10px;
        height:10px;
        background-color: #000000;
    }
</style>
<!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script> -->
</head>
<body>
<p>Sand Table Sim</p>
<canvas id="table-canvas" onmousedown="mouseclicktable(event);"></canvas>
<image id="sand" src="./SandTableImage2.png" onmousedown="mouseclickimg(event);"></image>
<div class="colourTableDiv">
    <div class="colourTableWhole">
        <p>Colour table</p>
        <table class="colourTable" id="colourTable">
            <tr><th>Idx</th><th>ColourStr</th></tr>
            <tr><td class="cidx">0</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">1</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">2</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">3</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">4</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">5</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">6</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">7</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">8</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
            <tr><td class="cidx">9</td><td><input class="colourStr" type="text"></td><td class="colourPatch"><div class="colourPatchDiv"></div></td></tr>
        </table>
    </div>
</div>
<div id="tooltip" style="display:inline"></div>
<script>

function rgb(r,g,b,a) {
    return [r,g,b,a];
}

class SandTableSim {
    constructor(ballSize, sandLevelSize, canvasBorder, options) {
        this.options = {
            canvasBorder: canvasBorder,
            sandLevelSize: Math.ceil(sandLevelSize),
            kernelSize: 2 * ballSize,
            ballPos: [sandLevelSize/2, sandLevelSize/2],
            ballSize: ballSize,
            sandStartLevel: ballSize/2,
            maxSandLevel: ballSize,
            imgPixSqSize: 5,
            numShadingRings: ballSize
        };

        this.evalExpr = {
            t: 0,
            x: sandLevelSize/2,
            y: sandLevelSize/2,
            r: 0
        };

        this.totalSandLoss = 0;

        this.sandColours = [
            // [rgb(166,120,84,255),rgb(164,118,82,255),rgb(156,110,74,255),rgb(151,107,68,255),rgb(170,126,87,255),rgb(161,115,79,255),rgb(165,119,83,255),rgb(179,133,97,255),rgb(156,111,73,255),rgb(171,127,88,255),rgb(149,103,67,255),rgb(158,112,76,255),rgb(158,112,76,255),rgb(169,123,86,255),rgb(170,125,86,255),rgb(162,116,80,255),rgb(154,108,72,255),rgb(154,108,72,255),rgb(165,119,83,255),rgb(162,117,78,255),rgb(151,106,67,255),rgb(148,103,64,255),rgb(160,115,76,255),rgb(162,116,79,255),rgb(158,112,76,255)],
            // [rgb(162,114,74,255),rgb(159,114,73,255),rgb(163,118,77,255),rgb(168,125,83,255),rgb(178,136,94,255),rgb(152,105,65,255),rgb(156,111,70,255),rgb(161,117,76,255),rgb(161,118,76,255),rgb(192,151,108,255),rgb(176,131,90,255),rgb(165,120,79,255),rgb(176,133,91,255),rgb(163,121,79,255),rgb(168,128,85,255),rgb(171,126,87,255),rgb(163,119,80,255),rgb(163,119,80,255),rgb(154,113,72,255),rgb(166,128,86,255),rgb(169,124,85,255),rgb(159,114,75,255),rgb(151,107,68,255),rgb(168,129,88,255),rgb(190,153,111,255)],
            // [rgb(170,128,86,255),rgb(163,121,79,255),rgb(156,114,72,255),rgb(151,109,67,255),rgb(146,104,62,255),rgb(160,117,75,255),rgb(159,116,74,255),rgb(151,108,66,255),rgb(149,106,64,255),rgb(149,106,65,255),rgb(149,104,65,255),rgb(153,108,69,255),rgb(146,102,63,255),rgb(148,104,66,255),rgb(154,112,73,255),rgb(148,103,64,255),rgb(152,106,70,255),rgb(144,100,63,255),rgb(141,98,60,255),rgb(139,97,59,255),rgb(144,99,60,255),rgb(157,113,76,255),rgb(152,108,71,255),rgb(131,89,51,255),rgb(153,111,73,255)],
            // [rgb(180,146,109,255),rgb(188,153,113,255),rgb(187,152,110,255),rgb(195,160,118,255),rgb(201,167,122,255),rgb(185,151,113,255),rgb(191,156,116,255),rgb(192,157,115,255),rgb(194,159,117,255),rgb(194,160,116,255),rgb(192,158,120,255),rgb(198,163,123,255),rgb(200,165,123,255),rgb(205,171,129,255),rgb(200,167,123,255),rgb(195,161,123,255),rgb(197,162,120,255),rgb(199,164,122,255),rgb(212,179,136,255),rgb(206,173,128,255),rgb(190,157,116,255),rgb(197,164,121,255),rgb(201,168,125,255),rgb(206,173,130,255),rgb(206,174,129,255)],
            // [rgb(201,164,122,255),rgb(195,157,116,255),rgb(180,141,100,255),rgb(178,138,97,255),rgb(165,123,83,255),rgb(194,157,115,255),rgb(186,148,106,255),rgb(178,139,98,255),rgb(165,126,85,255),rgb(155,116,75,255),rgb(188,151,109,255),rgb(181,143,102,255),rgb(166,128,86,255),rgb(169,130,89,255),rgb(158,119,78,255),rgb(196,160,117,255),rgb(184,147,104,255),rgb(156,119,76,255),rgb(145,106,64,255),rgb(139,100,58,255),rgb(188,154,109,255),rgb(170,134,89,255),rgb(154,117,73,255),rgb(146,109,65,255),rgb(133,95,52,255)],
            // [rgb(209,176,131,255),rgb(209,176,131,255),rgb(208,175,130,255),rgb(210,177,132,255),rgb(207,173,128,255),rgb(214,181,136,255),rgb(210,176,131,255),rgb(207,173,128,255),rgb(204,170,125,255),rgb(203,166,122,255),rgb(208,174,129,255),rgb(208,174,129,255),rgb(207,171,127,255),rgb(202,166,121,255),rgb(197,160,116,255),rgb(209,175,130,255),rgb(204,170,125,255),rgb(203,166,122,255),rgb(207,170,126,255),rgb(192,155,111,255),rgb(201,166,121,255),rgb(204,167,123,255),rgb(201,164,120,255),rgb(201,162,119,255),rgb(201,162,119,255)],
            // [rgb(213,180,135,255),rgb(208,176,129,255),rgb(207,175,128,255),rgb(203,170,125,255),rgb(211,178,133,255),rgb(207,176,130,255),rgb(209,178,131,255),rgb(209,178,131,255),rgb(205,172,127,255),rgb(208,175,130,255),rgb(207,176,130,255),rgb(208,177,130,255),rgb(211,180,133,255),rgb(215,182,137,255),rgb(213,180,135,255),rgb(209,178,132,255),rgb(210,179,132,255),rgb(210,179,132,255),rgb(213,180,135,255),rgb(210,177,132,255),rgb(211,180,134,255),rgb(213,182,135,255),rgb(210,179,132,255),rgb(215,182,137,255),rgb(208,175,130,255)],
            // [rgb(206,177,133,255),rgb(208,181,136,255),rgb(213,186,141,255),rgb(211,182,138,255),rgb(201,173,126,255),rgb(204,175,131,255),rgb(206,178,133,255),rgb(210,183,138,255),rgb(211,182,138,255),rgb(210,182,135,255),rgb(203,174,130,255),rgb(210,183,138,255),rgb(210,183,138,255),rgb(206,177,133,255),rgb(206,178,131,255),rgb(209,180,136,255),rgb(211,184,139,255),rgb(214,187,142,255),rgb(212,183,139,255),rgb(211,183,136,255),rgb(206,177,133,255),rgb(216,189,144,255),rgb(221,194,149,255),rgb(216,187,143,255),rgb(207,179,132,255)],
            // [rgb(215,187,147,255),rgb(217,189,149,255),rgb(216,188,148,255),rgb(219,191,151,255),rgb(219,191,151,255),rgb(215,187,147,255),rgb(219,191,151,255),rgb(219,191,151,255),rgb(220,192,152,255),rgb(220,192,152,255),rgb(214,186,147,255),rgb(217,189,149,255),rgb(220,192,152,255),rgb(221,193,153,255),rgb(219,192,149,255),rgb(216,188,149,255),rgb(216,188,148,255),rgb(217,189,149,255),rgb(218,190,150,255),rgb(218,191,148,255),rgb(219,191,152,255),rgb(219,191,151,255),rgb(218,190,150,255),rgb(215,187,147,255),rgb(217,190,147,255)],
            // [rgb(230,209,170,255),rgb(232,210,171,255),rgb(225,203,163,255),rgb(231,209,168,255),rgb(233,210,169,255),rgb(229,209,167,255),rgb(230,208,167,255),rgb(229,207,165,255),rgb(226,203,161,255),rgb(227,204,162,255),rgb(227,206,164,255),rgb(214,193,150,255),rgb(220,198,154,255),rgb(222,199,155,255),rgb(225,202,158,255),rgb(228,206,163,255),rgb(217,196,152,255),rgb(222,200,155,255),rgb(225,202,157,255),rgb(227,203,158,255),rgb(227,203,159,255),rgb(226,204,159,255),rgb(223,202,156,255),rgb(233,210,163,255),rgb(227,203,157,255)]
            // [rgb(222,210,150,255),rgb(223,212,150,255),rgb(198,187,123,255),rgb(199,185,120,255),rgb(209,194,127,255),rgb(203,191,131,255),rgb(204,193,130,255),rgb(218,206,142,255),rgb(216,202,137,255),rgb(197,182,115,255),rgb(224,212,152,255),rgb(198,187,124,255),rgb(211,200,136,255),rgb(218,205,138,255),rgb(216,201,134,255),rgb(219,207,147,255),rgb(195,184,120,255),rgb(218,207,142,255),rgb(231,218,151,255),rgb(204,189,120,255),rgb(235,223,162,255),rgb(231,220,157,255),rgb(181,170,104,255),rgb(204,191,124,255),rgb(203,188,119,255)],
            // [rgb(222,210,150,255),rgb(223,212,150,255),rgb(198,187,123,255),rgb(199,185,120,255),rgb(209,194,127,255),rgb(203,191,131,255),rgb(204,193,130,255),rgb(218,206,142,255),rgb(216,202,137,255),rgb(197,182,115,255),rgb(224,212,152,255),rgb(198,187,124,255),rgb(211,200,136,255),rgb(218,205,138,255),rgb(216,201,134,255),rgb(219,207,147,255),rgb(195,184,120,255),rgb(218,207,142,255),rgb(231,218,151,255),rgb(204,189,120,255),rgb(235,223,162,255),rgb(231,220,157,255),rgb(181,170,104,255),rgb(204,191,124,255),rgb(203,188,119,255)],
            // [rgb(222,210,150,255),rgb(223,212,150,255),rgb(198,187,123,255),rgb(199,185,120,255),rgb(209,194,127,255),rgb(203,191,131,255),rgb(204,193,130,255),rgb(218,206,142,255),rgb(216,202,137,255),rgb(197,182,115,255),rgb(224,212,152,255),rgb(198,187,124,255),rgb(211,200,136,255),rgb(218,205,138,255),rgb(216,201,134,255),rgb(219,207,147,255),rgb(195,184,120,255),rgb(218,207,142,255),rgb(231,218,151,255),rgb(204,189,120,255),rgb(235,223,162,255),rgb(231,220,157,255),rgb(181,170,104,255),rgb(204,191,124,255),rgb(203,188,119,255)],
            // [rgb(222,210,150,255),rgb(223,212,150,255),rgb(198,187,123,255),rgb(199,185,120,255),rgb(209,194,127,255),rgb(203,191,131,255),rgb(204,193,130,255),rgb(218,206,142,255),rgb(216,202,137,255),rgb(197,182,115,255),rgb(224,212,152,255),rgb(198,187,124,255),rgb(211,200,136,255),rgb(218,205,138,255),rgb(216,201,134,255),rgb(219,207,147,255),rgb(195,184,120,255),rgb(218,207,142,255),rgb(231,218,151,255),rgb(204,189,120,255),rgb(235,223,162,255),rgb(231,220,157,255),rgb(181,170,104,255),rgb(204,191,124,255),rgb(203,188,119,255)],
            // [rgb(222,210,150,255),rgb(223,212,150,255),rgb(198,187,123,255),rgb(199,185,120,255),rgb(209,194,127,255),rgb(203,191,131,255),rgb(204,193,130,255),rgb(218,206,142,255),rgb(216,202,137,255),rgb(197,182,115,255),rgb(224,212,152,255),rgb(198,187,124,255),rgb(211,200,136,255),rgb(218,205,138,255),rgb(216,201,134,255),rgb(219,207,147,255),rgb(195,184,120,255),rgb(218,207,142,255),rgb(231,218,151,255),rgb(204,189,120,255),rgb(235,223,162,255),rgb(231,220,157,255),rgb(181,170,104,255),rgb(204,191,124,255),rgb(203,188,119,255)],
            // [rgb(222,210,150,255),rgb(223,212,150,255),rgb(198,187,123,255),rgb(199,185,120,255),rgb(209,194,127,255),rgb(203,191,131,255),rgb(204,193,130,255),rgb(218,206,142,255),rgb(216,202,137,255),rgb(197,182,115,255),rgb(224,212,152,255),rgb(198,187,124,255),rgb(211,200,136,255),rgb(218,205,138,255),rgb(216,201,134,255),rgb(219,207,147,255),rgb(195,184,120,255),rgb(218,207,142,255),rgb(231,218,151,255),rgb(204,189,120,255),rgb(235,223,162,255),rgb(231,220,157,255),rgb(181,170,104,255),rgb(204,191,124,255),rgb(203,188,119,255)],
            // [rgb(222,210,150,255),rgb(223,212,150,255),rgb(198,187,123,255),rgb(199,185,120,255),rgb(209,194,127,255),rgb(203,191,131,255),rgb(204,193,130,255),rgb(218,206,142,255),rgb(216,202,137,255),rgb(197,182,115,255),rgb(224,212,152,255),rgb(198,187,124,255),rgb(211,200,136,255),rgb(218,205,138,255),rgb(216,201,134,255),rgb(219,207,147,255),rgb(195,184,120,255),rgb(218,207,142,255),rgb(231,218,151,255),rgb(204,189,120,255),rgb(235,223,162,255),rgb(231,220,157,255),rgb(181,170,104,255),rgb(204,191,124,255),rgb(203,188,119,255)],
            // [rgb(222,210,150,255),rgb(223,212,150,255),rgb(198,187,123,255),rgb(199,185,120,255),rgb(209,194,127,255),rgb(203,191,131,255),rgb(204,193,130,255),rgb(218,206,142,255),rgb(216,202,137,255),rgb(197,182,115,255),rgb(224,212,152,255),rgb(198,187,124,255),rgb(211,200,136,255),rgb(218,205,138,255),rgb(216,201,134,255),rgb(219,207,147,255),rgb(195,184,120,255),rgb(218,207,142,255),rgb(231,218,151,255),rgb(204,189,120,255),rgb(235,223,162,255),rgb(231,220,157,255),rgb(181,170,104,255),rgb(204,191,124,255),rgb(203,188,119,255)],
            // [rgb(222,210,150,255),rgb(223,212,150,255),rgb(198,187,123,255),rgb(199,185,120,255),rgb(209,194,127,255),rgb(203,191,131,255),rgb(204,193,130,255),rgb(218,206,142,255),rgb(216,202,137,255),rgb(197,182,115,255),rgb(224,212,152,255),rgb(198,187,124,255),rgb(211,200,136,255),rgb(218,205,138,255),rgb(216,201,134,255),rgb(219,207,147,255),rgb(195,184,120,255),rgb(218,207,142,255),rgb(231,218,151,255),rgb(204,189,120,255),rgb(235,223,162,255),rgb(231,220,157,255),rgb(181,170,104,255),rgb(204,191,124,255),rgb(203,188,119,255)],
            // // [rgb(222,210,150,255),rgb(223,212,150,255),rgb(198,187,123,255),rgb(199,185,120,255),rgb(209,194,127,255),rgb(203,191,131,255),rgb(204,193,130,255),rgb(218,206,142,255),rgb(216,202,137,255),rgb(197,182,115,255),rgb(224,212,152,255),rgb(198,187,124,255),rgb(211,200,136,255),rgb(218,205,138,255),rgb(216,201,134,255),rgb(219,207,147,255),rgb(195,184,120,255),rgb(218,207,142,255),rgb(231,218,151,255),rgb(204,189,120,255),rgb(235,223,162,255),rgb(231,220,157,255),rgb(181,170,104,255),rgb(204,191,124,255),rgb(203,188,119,255)]
            // [rgb(21,15,1,255),rgb(21,15,1,255),rgb(6,4,0,255),rgb(0,0,0,255),rgb(0,0,0,255),rgb(22,16,2,255),rgb(22,16,2,255),rgb(6,5,1,255),rgb(0,0,0,255),rgb(0,0,0,255),rgb(23,17,5,255),rgb(23,17,5,255),rgb(7,5,1,255),rgb(0,0,0,255),rgb(0,0,0,255),rgb(23,17,5,255),rgb(23,17,5,255),rgb(7,5,1,255),rgb(0,0,0,255),rgb(0,0,0,255),rgb(23,17,5,255),rgb(23,17,5,255),rgb(7,5,1,255),rgb(0,0,0,255),rgb(0,0,0,255)],
            // [rgb(26,20,4,255),rgb(25,19,5,255),rgb(24,18,4,255),rgb(23,17,5,255),rgb(23,17,5,255),rgb(26,20,4,255),rgb(25,19,5,255),rgb(24,18,4,255),rgb(23,17,5,255),rgb(23,17,5,255),rgb(26,20,5,255),rgb(25,19,5,255),rgb(24,18,4,255),rgb(23,17,5,255),rgb(23,17,5,255),rgb(27,21,5,255),rgb(25,19,5,255),rgb(24,18,4,255),rgb(23,17,5,255),rgb(23,17,5,255),rgb(27,21,6,255),rgb(26,20,6,255),rgb(24,18,4,255),rgb(23,17,5,255),rgb(22,16,4,255)],
            // [rgb(28,24,5,255),rgb(28,23,6,255),rgb(28,22,6,255),rgb(26,20,5,255),rgb(25,19,5,255),rgb(30,25,6,255),rgb(29,24,7,255),rgb(28,22,6,255),rgb(27,21,5,255),rgb(25,19,5,255),rgb(31,26,7,255),rgb(30,25,7,255),rgb(29,23,7,255),rgb(27,21,6,255),rgb(26,20,6,255),rgb(32,27,8,255),rgb(31,25,8,255),rgb(30,24,8,255),rgb(28,22,6,255),rgb(26,20,6,255),rgb(33,28,9,255),rgb(32,26,9,255),rgb(30,24,8,255),rgb(28,22,7,255),rgb(26,20,6,255)],
            // [rgb(41,37,10,255),rgb(39,35,12,255),rgb(33,29,8,255),rgb(32,27,8,255),rgb(31,25,8,255),rgb(44,40,11,255),rgb(40,36,12,255),rgb(34,29,9,255),rgb(33,28,9,255),rgb(32,26,9,255),rgb(46,40,11,255),rgb(40,36,11,255),rgb(35,29,9,255),rgb(33,28,9,255),rgb(32,26,9,255),rgb(47,41,12,255),rgb(41,35,10,255),rgb(37,30,10,255),rgb(34,28,10,255),rgb(32,26,9,255),rgb(51,45,14,255),rgb(41,35,9,255),rgb(39,32,12,255),rgb(36,29,11,255),rgb(33,26,9,255)],
            // [rgb(65,58,16,255),rgb(52,45,10,255),rgb(46,40,11,255),rgb(40,36,11,255),rgb(35,29,9,255),rgb(69,61,19,255),rgb(53,45,10,255),rgb(47,41,12,255),rgb(41,35,10,255),rgb(37,30,10,255),rgb(71,63,20,255),rgb(55,47,12,255),rgb(51,45,14,255),rgb(41,35,9,255),rgb(39,32,12,255),rgb(73,65,23,255),rgb(58,50,16,255),rgb(51,44,15,255),rgb(42,35,9,255),rgb(38,31,12,255),rgb(70,62,19,255),rgb(56,48,13,255),rgb(50,43,15,255),rgb(39,33,9,255),rgb(37,30,11,255)],
            // [rgb(148,141,78,255),rgb(124,116,59,255),rgb(98,90,40,255),rgb(73,65,23,255),rgb(58,50,16,255),rgb(150,142,80,255),rgb(121,112,55,255),rgb(93,85,35,255),rgb(70,62,19,255),rgb(56,48,13,255),rgb(137,132,69,255),rgb(107,100,44,255),rgb(85,78,29,255),rgb(70,63,22,255),rgb(57,50,16,255),rgb(112,107,45,255),rgb(89,83,27,255),rgb(77,69,24,255),rgb(65,57,20,255),rgb(52,46,15,255),rgb(93,88,29,255),rgb(73,67,14,255),rgb(65,58,14,255),rgb(56,49,14,255),rgb(48,41,12,255)],
            // [rgb(242,238,204,255),rgb(196,193,137,255),rgb(166,163,97,255),rgb(137,132,69,255),rgb(107,100,44,255),rgb(227,223,189,255),rgb(163,162,106,255),rgb(156,153,89,255),rgb(112,107,45,255),rgb(89,83,27,255),rgb(221,218,184,255),rgb(148,147,91,255),rgb(149,147,84,255),rgb(93,88,29,255),rgb(73,67,14,255),rgb(225,222,188,255),rgb(147,146,91,255),rgb(147,146,83,255),rgb(85,81,23,255),rgb(67,61,10,255),rgb(233,231,199,255),rgb(161,160,109,255),rgb(149,147,88,255),rgb(91,86,31,255),rgb(66,60,10,255)],
            // [rgb(253,252,238,255),rgb(248,245,225,255),rgb(221,218,184,255),rgb(148,147,91,255),rgb(149,147,84,255),rgb(254,253,239,255),rgb(251,247,228,255),rgb(225,222,188,255),rgb(147,146,91,255),rgb(147,146,83,255),rgb(252,251,237,255),rgb(252,250,231,255),rgb(233,231,199,255),rgb(161,160,109,255),rgb(149,147,88,255),rgb(250,251,237,255),rgb(251,251,234,255),rgb(241,240,214,255),rgb(185,184,141,255),rgb(149,146,96,255),rgb(251,253,239,255),rgb(250,251,236,255),rgb(246,247,226,255),rgb(209,208,175,255),rgb(146,143,103,255)],
            // [rgb(247,249,230,255),rgb(251,252,237,255),rgb(250,252,238,255),rgb(250,251,237,255),rgb(251,251,234,255),rgb(238,239,216,255),rgb(246,247,229,255),rgb(251,253,238,255),rgb(251,253,239,255),rgb(250,251,236,255),rgb(235,234,206,255),rgb(238,239,215,255),rgb(247,249,230,255),rgb(251,253,236,255),rgb(249,251,235,255),rgb(243,243,207,255),rgb(247,246,215,255),rgb(252,252,226,255),rgb(254,254,232,255),rgb(253,254,232,255),rgb(223,220,177,255),rgb(218,216,176,255),rgb(235,234,198,255),rgb(252,252,223,255),rgb(255,255,232,255)],
            // [rgb(220,219,179,255),rgb(235,237,200,255),rgb(237,236,204,255),rgb(235,234,206,255),rgb(238,239,215,255),rgb(205,203,158,255),rgb(205,205,163,255),rgb(249,247,207,255),rgb(243,243,207,255),rgb(247,246,215,255),rgb(204,202,152,255),rgb(209,207,158,255),rgb(227,225,177,255),rgb(223,220,177,255),rgb(218,216,176,255),rgb(230,228,171,255),rgb(228,226,168,255),rgb(212,207,152,255),rgb(214,209,156,255),rgb(200,196,147,255),rgb(221,217,157,255),rgb(206,202,139,255),rgb(217,211,151,255),rgb(219,212,152,255),rgb(207,201,144,255)]

[rgb(206,168,99,255),rgb(150,128,70,255),rgb(144,122,64,255),rgb(153,131,73,255),rgb(155,133,75,255),rgb(181,159,99,255),rgb(161,139,80,255),rgb(153,131,71,255),rgb(170,148,90,255),rgb(166,144,86,255),rgb(193,171,111,255),rgb(174,152,92,255),rgb(170,148,88,255),rgb(180,158,100,255),rgb(175,153,95,255),rgb(187,165,105,255),rgb(180,158,98,255),rgb(182,160,100,255),rgb(180,158,99,255),rgb(169,147,89,255),rgb(183,162,102,255),rgb(179,157,97,255),rgb(182,160,100,255),rgb(186,164,105,255),rgb(177,155,96,255)],
[rgb(191,156,94,255),rgb(168,146,89,255),rgb(165,143,86,255),rgb(169,147,90,255),rgb(159,138,81,255),rgb(178,156,98,255),rgb(179,158,99,255),rgb(165,143,85,255),rgb(166,144,86,255),rgb(166,145,87,255),rgb(168,147,88,255),rgb(186,166,107,255),rgb(190,169,109,255),rgb(178,157,98,255),rgb(166,145,86,255),rgb(183,164,103,255),rgb(156,137,76,255),rgb(158,139,77,255),rgb(162,142,81,255),rgb(142,122,63,255),rgb(182,164,102,255),rgb(178,160,98,255),rgb(166,148,86,255),rgb(183,165,103,255),rgb(177,158,98,255)],
[rgb(171,141,89,255),rgb(147,126,71,255),rgb(142,121,66,255),rgb(136,113,60,255),rgb(127,104,52,255),rgb(150,129,72,255),rgb(150,129,73,255),rgb(155,134,79,255),rgb(149,126,73,255),rgb(139,116,64,255),rgb(145,124,67,255),rgb(139,118,62,255),rgb(150,129,74,255),rgb(157,135,82,255),rgb(155,133,80,255),rgb(142,121,64,255),rgb(137,116,60,255),rgb(146,125,70,255),rgb(164,142,89,255),rgb(170,147,95,255),rgb(152,131,74,255),rgb(155,134,78,255),rgb(160,139,84,255),rgb(166,144,90,255),rgb(168,145,92,255)],
[rgb(158,131,82,255),rgb(158,135,85,255),rgb(157,134,85,255),rgb(135,111,63,255),rgb(133,109,60,255),rgb(162,139,87,255),rgb(154,131,79,255),rgb(133,110,60,255),rgb(137,114,64,255),rgb(144,121,71,255),rgb(167,144,92,255),rgb(164,141,89,255),rgb(144,121,70,255),rgb(140,117,66,255),rgb(143,120,70,255),rgb(167,144,92,255),rgb(156,133,81,255),rgb(143,121,69,255),rgb(135,112,60,255),rgb(132,109,58,255),rgb(168,145,93,255),rgb(155,132,80,255),rgb(143,120,68,255),rgb(143,120,68,255),rgb(141,118,66,255)],
[rgb(143,119,76,255),rgb(125,100,52,255),rgb(127,102,55,255),rgb(132,107,61,255),rgb(129,105,60,255),rgb(143,117,69,255),rgb(127,100,52,255),rgb(130,103,56,255),rgb(139,114,67,255),rgb(138,114,68,255),rgb(145,119,70,255),rgb(135,108,60,255),rgb(134,107,60,255),rgb(144,119,72,255),rgb(140,115,69,255),rgb(136,110,61,255),rgb(143,117,68,255),rgb(139,112,65,255),rgb(143,117,71,255),rgb(140,115,69,255),rgb(123,96,47,255),rgb(146,120,71,255),rgb(148,122,72,255),rgb(135,108,60,255),rgb(126,101,53,255)],
[rgb(138,112,65,255),rgb(144,120,75,255),rgb(149,126,81,255),rgb(126,102,58,255),rgb(110,86,43,255),rgb(111,86,38,255),rgb(134,110,64,255),rgb(143,120,74,255),rgb(121,97,53,255),rgb(99,76,32,255),rgb(119,95,46,255),rgb(127,103,56,255),rgb(136,112,66,255),rgb(131,107,62,255),rgb(129,105,61,255),rgb(144,119,71,255),rgb(134,110,62,255),rgb(123,99,53,255),rgb(118,94,49,255),rgb(120,96,52,255),rgb(141,116,68,255),rgb(125,101,53,255),rgb(121,97,50,255),rgb(112,88,43,255),rgb(108,84,39,255)],
[rgb(130,105,60,255),rgb(94,70,26,255),rgb(97,73,31,255),rgb(108,84,43,255),rgb(107,83,43,255),rgb(102,78,33,255),rgb(87,63,18,255),rgb(100,75,32,255),rgb(109,85,42,255),rgb(107,82,41,255),rgb(116,92,45,255),rgb(112,87,41,255),rgb(127,103,57,255),rgb(130,105,61,255),rgb(122,97,54,255),rgb(128,101,53,255),rgb(144,117,70,255),rgb(152,125,79,255),rgb(142,115,70,255),rgb(124,97,52,255),rgb(132,106,57,255),rgb(141,115,66,255),rgb(122,96,48,255),rgb(98,72,24,255),rgb(91,64,17,255)],
[rgb(121,98,55,255),rgb(124,99,61,255),rgb(113,88,51,255),rgb(109,85,49,255),rgb(103,79,44,255),rgb(127,102,60,255),rgb(124,99,58,255),rgb(113,89,50,255),rgb(106,82,45,255),rgb(97,73,37,255),rgb(132,106,63,255),rgb(121,96,55,255),rgb(107,83,43,255),rgb(104,80,42,255),rgb(103,80,44,255),rgb(128,102,58,255),rgb(119,95,53,255),rgb(105,81,41,255),rgb(103,79,41,255),rgb(105,81,45,255),rgb(119,94,50,255),rgb(112,88,46,255),rgb(111,86,46,255),rgb(111,86,48,255),rgb(107,84,46,255)],
[rgb(111,90,52,255),rgb(83,62,28,255),rgb(90,69,36,255),rgb(96,74,42,255),rgb(92,70,38,255),rgb(80,58,24,255),rgb(84,62,29,255),rgb(93,70,38,255),rgb(96,73,41,255),rgb(89,66,33,255),rgb(79,55,22,255),rgb(81,56,26,255),rgb(82,58,27,255),rgb(81,58,26,255),rgb(79,56,24,255),rgb(98,73,41,255),rgb(94,69,38,255),rgb(88,63,32,255),rgb(81,57,25,255),rgb(78,54,21,255),rgb(103,79,46,255),rgb(88,64,32,255),rgb(79,54,23,255),rgb(76,51,19,255),rgb(74,50,17,255)],
[rgb(97,78,45,255),rgb(92,68,40,255),rgb(89,65,39,255),rgb(87,63,38,255),rgb(87,63,38,255),rgb(76,53,24,255),rgb(82,58,30,255),rgb(81,57,30,255),rgb(73,49,24,255),rgb(69,45,20,255),rgb(72,48,19,255),rgb(72,47,19,255),rgb(70,45,19,255),rgb(65,41,15,255),rgb(62,38,13,255),rgb(80,55,24,255),rgb(72,47,19,255),rgb(70,45,18,255),rgb(71,47,21,255),rgb(71,47,23,255),rgb(91,66,35,255),rgb(80,55,26,255),rgb(75,51,23,255),rgb(77,53,27,255),rgb(79,55,31,255)]

        ];
        this.options = Object.assign(this.options, options);
        this.initSand();

    }
    initSand()
    {
        this.sandToPixelScaleFactor = this.sandColours.length / this.options.maxSandLevel;
        this.createSand();
        this.createKernel();
        this.showSand();
    }
    createSand() {
        let sandLevelSize = this.options.sandLevelSize;
        // Generate a 2D array of distances from the centre of the kernel
        this.sandLevel = new Array(sandLevelSize);
        for (let i = 0; i < sandLevelSize; i++)
        {
            this.sandLevel[i] = new Array(sandLevelSize);
            for (let j = 0; j < sandLevelSize; j++)
            {
                this.sandLevel[i][j] = this.options.sandStartLevel;
                // console.log(i + "," + j + "," + this.kernel[i][j]);
            }
        }
    }

    createKernel() {
        let kernelSize = this.options.kernelSize;
        let kernelDistSize = kernelSize*2;
        // Generate a 2D (square) array of distances from the centre of the square
        let bs = this.options.ballSize;
        this.kernelRingDistances = [bs/20,bs/10,bs/4,bs/3,bs/2,bs*0.75]
        this.kernelDistSquare = new Array(kernelDistSize);
        for (let i = 0; i < kernelDistSize; i++)
        {
            this.kernelDistSquare[i] = new Array(kernelDistSize);
            for (let j = 0; j < kernelDistSize; j++)
            {
                let distFromCtr = Math.round(Math.sqrt((Math.pow(i - kernelDistSize/2, 2)) + (Math.pow(j - kernelDistSize/2, 2))));
                let ringIdx = 0;
                for (let k = 0; k < this.kernelRingDistances.length; k++) {
                    if (distFromCtr <= this.kernelRingDistances[k])
                        break;
                    ringIdx++;
                }
                this.kernelDistSquare[i][j] = ringIdx;
                // console.log(i + "," + j + "," + this.kernel[i][j]);
            }
        }
        // Create a series of rings (lists of pixels at approx equal distances from kernel centre)
        this.numKernelRings = this.kernelRingDistances.length;
        this.fullCircleKernelLists = new Array();
        for (let k = 0; k < this.numKernelRings; k++)
            this.fullCircleKernelLists[k] = [];
        let offsetDistCoordsToKernelCoords = (kernelDistSize-kernelSize)/2;
        for (let i = 0; i < kernelDistSize; i++)
        {
            for (let j = 0; j < kernelDistSize; j++)
            {
                let kernelRingIdx = this.kernelDistSquare[i][j];
                if (kernelRingIdx < this.numKernelRings)
                    this.fullCircleKernelLists[kernelRingIdx].push([i-offsetDistCoordsToKernelCoords,j-offsetDistCoordsToKernelCoords]);
            }
        }
        for (let k = 0; k < this.numKernelRings; k++)
            console.log("Ks " + this.fullCircleKernelLists[k].length);
        // Sand amount to move at each ring of distance - this is like a threshold level (curvature of ball bearing)
        this.kernelMoveThreshold = new Array(this.numKernelRings);
        for (let k = 0; k < this.numKernelRings; k++) {
            // this.kernelMoveThreshold[k] = (this.options.ballSize/2) * Math.sin(k * Math.PI / kernelSize);
            let thirdSide = Math.sqrt(Math.pow(this.options.ballSize/2,2) - Math.pow(this.kernelRingDistances[k],2))
            let pressBeyondBall = this.options.maxSandLevel;
            this.kernelMoveThreshold[k] = (this.kernelRingDistances[k] < this.options.ballSize/2) ? this.options.ballSize/2 - thirdSide : pressBeyondBall;
            console.log("moveThreshold " + this.kernelRingDistances[k] + " = " + this.kernelMoveThreshold[k]);
        }
        // For each of a number of angle ranges, calculate lists of "sand pixels" are within that angle range
        this.kernelAngleRanges = 32;
        this.kernelSrcDests = new Array(this.kernelAngleRanges);
        let kSize = this.options.kernelSize;
        for (let i = 0; i < this.kernelSrcDests.length; i++) {
            // Angle
            let directionAngle = i * 2 * Math.PI / this.kernelAngleRanges;
            // Create array of source/dest info
            this.kernelSrcDests[i] = Array(this.numKernelRings-1);
            // Iterate base list and find which source rings are at the appropriate angle
            for (let k = 0; k < this.numKernelRings-1; k++) {
                this.kernelSrcDests[i][k] = []
                // Iterate the list of potential source sand pixels at this ring
                let kernelRing = this.fullCircleKernelLists[k];
                for (let s = 0; s < kernelRing.length; s++) {
                    // Check if this sand pixel is within the angle range for source
                    let sandPixPtOffset = kernelRing[s];
                    let angleOfSourceSandPixel = this.getAngleFromPoint(sandPixPtOffset, [kSize/2,kSize/2]);
                    // console.log("Sourceang " + angleOfSandPixel + " moveAngle " + directionAngle);
                    if (this.compareAngleOffset(angleOfSourceSandPixel, directionAngle, -Math.PI / 2, Math.PI / 2)) {
                        // Get the list of destination sand pixels for this sand pixel
                        let destRing = this.fullCircleKernelLists[k + 1];
                        let destPtList = [];
                        for (let t = 0; t < destRing.length; t++) {
                            // Get the angle to this sand pixel
                            let destKernelPt = destRing[t];
                            let angleOfDestSandPixel = this.getAngleFromPoint(destKernelPt, sandPixPtOffset);
                            // let log2RingLen = Math.log2(destRing.length);
                            // if (i == 16 && k == 4 && s == 4)
                            //     console.log("src " + sandPixPtOffset + " dest " + destKernelPt + " dang " + angleOfDestSandPixel + 
                            //         " srcAng " + angleOfSourceSandPixel + " dirnAng " + directionAngle + " low " + (-Math.PI / log2RingLen) + " hi " + Math.PI / log2RingLen +
                            //         " val " + (angleOfDestSandPixel - angleOfSourceSandPixel - (2 * Math.PI)) + " lpg2 " + log2RingLen);
                            if (this.compareAngleOffset(angleOfDestSandPixel, angleOfSourceSandPixel, -Math.PI / 4, Math.PI / 4)) {
                                destPtList.push(destKernelPt);
                            }
                        }
                        // Add source point and dest list
                        if (destPtList.length > 0)
                            this.kernelSrcDests[i][k].push({ srcPt: sandPixPtOffset, destPts: destPtList});
                    }
                }
            }
        }
        // console.log("Angle 16 ring 4 " + this.kernelSrcDests[16][4][4].srcPt + ", " + this.kernelSrcDests[16][4][4].destPts);
        // Create shading rings
        this.shadingRings = [
            [[-1,-1],[1,-1],[1,1],[-1,1]],
            [[-3,0],[-2,2],[0,3],[2,2],[3,0],[2,-2],[0,-3],[-2,-2]],
            [[-5,-6],[-7,-2],[-7,2],[-5,6],[-2,7],[2,7],[5,6],[7,2],[7,-2],[5,-6],[2,-7],[-2,-7]]
            ];

        // for (let i = 0; i < this.kernelSrcDests.length; i++)
        // {
        //     let srcDest = this.kernelSrcDests[i]
        //     for (let j = 0; j < srcDest.length; j++)
        //     {
        //         let ring = srcDest[j]
        //         console.log("Direction " + i + " ring " + j)
        //         for (let k = 0; k < ring.length; k++)
        //         {

        //             console.log(ring[k].srcPt + "->" + ring[k].destPts)
        //         }
        //     }
        // }
    }

    getAngleFromPoint(toPt, fromPt) {
        let diffAngle = Math.atan2(fromPt[1] - toPt[1], toPt[0] - fromPt[0]);
        return diffAngle;
    }

    compareAngleOffset(ang, offset, lowRange, highRange)
    {
        let diffAngle = ang - offset;
        // Correct wrapping around circle
        if (diffAngle < -Math.PI)
            diffAngle += 2 * Math.PI;
        if (diffAngle > Math.PI)
            diffAngle -= 2 * Math.PI;
        return (diffAngle > lowRange && diffAngle < highRange);
    }

    dumpSand() {
        console.log("Sand!");
        let sandLevelSize = this.options.sandLevelSize;
        for (let i = 0; i < sandLevelSize; i++)
        {
            let sss = "";
            for (let j = 0; j < sandLevelSize; j++)
            {
                sss += ((j === 0) ? "" : ",") + this.sandLevel[i][j];
                // console.log(i + "," + j + "," + this.kernel[i][j]);
            }
            console.log(sss);
        }

    }

    moveSand(ballX, ballY, moveAngleACWFromEast) {
        ballX = Math.floor(ballX)
        ballY = Math.floor(ballY)
        // Work out from the centre of the ball bearing moving "sand"
        let kSize = this.options.kernelSize;
        let sandAccumulator = 0;
        // Calculate which direction range the ball is moving in
        let directionRange = Math.floor(this.kernelAngleRanges * ((moveAngleACWFromEast + 2 * Math.PI) % (2 * Math.PI)) / (2 * Math.PI));
        if (directionRange < 0)
            directionRange = 0;
        if (directionRange >= this.kernelAngleRanges)
            directionRange = this.kernelAngleRanges-1;
        // Get the list of sand pixel rings for this angle
        let sourceDests = this.kernelSrcDests[directionRange];
        // console.log("dirnRange " + directionRange)
        // Iterate the ring
        for (let k = 0; k < sourceDests.length; k++) {
            // Iterate the source sand pixels within the ring
            for (let j = 0; j < sourceDests[k].length; j++) {
                let sourcePtOffset = sourceDests[k][j].srcPt;
                let sourceSandPt = [Math.floor(sourcePtOffset[0] + ballX - this.options.kernelSize / 2), Math.floor(sourcePtOffset[1] + ballY - this.options.kernelSize / 2)];
                if (sourceSandPt[0] < 0 || sourceSandPt[0] >= this.options.sandLevelSize)
                    continue;
                if (sourceSandPt[1] < 0 || sourceSandPt[1] >= this.options.sandLevelSize)
                    continue;
                // Move all the sand above the threshold
                let sandToMove = this.sandLevel[sourceSandPt[0]][sourceSandPt[1]] - this.kernelMoveThreshold[k];
                if (sandToMove < 0)
                    sandToMove = 0;
                // console.log("SandQty at " + sourceSandPt[0] + ", g" + sourceSandPt[1] + " ring " + k + " = " + this.sandLevel[sourceSandPt[0]][sourceSandPt[1]] + " => " + this.kernelMoveThreshold[k]);
                // (" + this.kernelMoveThreshold[k] + ") = " + sandToMove + " total " + this.sandLevel[sourceSandPt[0]][sourceSandPt[1]]);
                this.sandLevel[sourceSandPt[0]][sourceSandPt[1]] -= sandToMove;


                // this.sandLevel[sourceSandPt[0]][sourceSandPt[1]] = 0;

                // if (isNaN(this.sandLevel[sourceSandPt[0]][sourceSandPt[1]]))
                //     debugger
                // Add sand acculumated from spill-over
                // console.log("SandToMove = " + sandToMove + ", sandAccumulator = " + sandAccumulator);
                // sandToMove += sandAccumulator;
                // sandAccumulator = 0;
                // Distribute to dest points
                let destPtList = sourceDests[k][j].destPts;
                if (destPtList.length == 0)
                    debugger;
                for (let i = 0; i < destPtList.length; i++) {
                    let destPtOffset = destPtList[i];
                    let destPt = [Math.floor(destPtOffset[0] + ballX - this.options.kernelSize / 2), Math.floor(destPtOffset[1] + ballY - this.options.kernelSize / 2)];
                    if (destPt[0] < 0 || destPt[0] >= this.options.sandLevelSize)
                        continue;
                    if (destPt[1] < 0 || destPt[1] >= this.options.sandLevelSize)
                        continue;


                    this.sandLevel[destPt[0]][destPt[1]] += sandToMove / destPtList.length;

                    // this.sandLevel[destPt[0]][destPt[1]] = 19.9;


                    if (isNaN(this.sandLevel[destPt[0]][destPt[1]]))
                        debugger
                    // If the sand level is above max then distribute to the next ring outwards using the sandAccumulator
                    if (this.sandLevel[destPt[0]][destPt[1]] >= this.options.maxSandLevel) {
                        sandAccumulator += this.sandLevel[destPt[0]][destPt[1]] - this.options.maxSandLevel + 0.01;
                        this.sandLevel[destPt[0]][destPt[1]] = this.options.maxSandLevel - 0.01;
                    }
                    // console.log("Dest at " + destPtList[i][0] + "," + destPtList[i][1] + " = " + this.sandLevel[destPtList[i][0]][destPtList[i][1]]);
                }
            }
        }

        // console.log("Final sandAccumulator " + sandAccumulator);

        // sandAccumulator += sandToMove;
        // Spread the left-over sand
        if (sandAccumulator > 0) {
            let tlx = Math.floor(ballX - this.options.kernelSize / 2);
            if (tlx < 0)
                tlx = 0;
            let tly = Math.floor(ballY - this.options.kernelSize / 2);
            if (tly < 0)
                tly = 0;
            let spreadX = Math.floor(tlx + this.options.kernelSize);
            if (spreadX >= this.options.sandLevelSize)
                spreadX = this.options.sandLevelSize - 1;
            let spreadY = Math.floor(tly + this.options.kernelSize);
            if (spreadY >= this.options.sandLevelSize)
                spreadY = this.options.sandLevelSize - 1;
            let sandToAdd = sandAccumulator / ((spreadX-tlx)*(spreadY-tly));
            for (let ix = tlx; ix < spreadX; ix++)
                for (let iy = tly; iy < spreadY; iy++)
                {
                    this.sandLevel[ix][iy] += sandToAdd;
                    sandAccumulator -= sandToAdd;
                }
        }

        this.totalSandLoss += sandAccumulator;

        // Redraw the image around the ball position
        this.recreateSandSquareImage([ballX,ballY], this.options.kernelSize*2);

        // this.tallySand();
    }

    randInt(min, max) {
        return Math.floor(Math.random() * (max - min) ) + min;
    }

    colourIndex(sandLevel) {
        if (sandLevel === undefined)
            return [0,0,0,0];
        let colourIdx = Math.floor(sandLevel * this.sandToPixelScaleFactor);
        if (colourIdx < 0)
            colourIdx = 0;
        if (colourIdx > this.sandColours.length-1)
            colourIdx = this.sandColours.length-1;
        return this.sandColours.length-1-colourIdx;
    }

    pixelLookup(sandLevel) {
        let sandRange = this.sandColours[this.colourIndex(sandLevel)];
        let pixColr = sandRange[this.randInt(0,sandRange.length)];
        return pixColr;
    }

    recreateSandSquareImage(changePos, changeSize) {
        var canvas = document.getElementById('table-canvas');
        var ctx = canvas.getContext('2d');
        var chgTLX = Math.floor(changePos[0]-changeSize/2);
        if (chgTLX < 0)
            chgTLX = 0;
        var chgTLY = Math.floor(changePos[1]-changeSize/2);
        if (chgTLY < 0)
            chgTLY = 0;
        var chgSq = ctx.getImageData(chgTLX, chgTLY,
                        changeSize,
                        changeSize);
        let k = 0;
        let changeSizeSqd = Math.pow(changeSize,2);
        for (let i = 0; i < changeSize; i++)
        {
            if (i + chgTLY >= this.options.sandLevelSize)
                break;
            for (let j = 0; j < changeSize; j++)
            {
                if (j + chgTLX >= this.options.sandLevelSize)
                    break;

                // Check if this pixel is within the circular area of changeSize
                if ((Math.pow(i-changeSize/2,2) + Math.pow(i-changeSize/2,2)) > changeSizeSqd)
                    continue;

                // Sand level at this point
                let ptSandLevel = this.sandLevel[j+chgTLX][i+chgTLY];

                // Go round shading rings around point to see if shaded by higher points
                let sandLevelShaded = 0;
                sandLevelShaded = ptSandLevel;
                // for (let k = 0; k < this.shadingRings.length; k++)
                // {
                //     let shadingRing = this.shadingRings[k];
                //     for (let l = 0; l < shadingRing.length; l++)
                //     {
                //         let testPtX = shadingRing[l][0] + j + chgTLX;
                //         let testPtY = shadingRing[l][1] + i + chgTLY;
                //         if ((testPtX < 0) || (testPtY < 0) || (testPtX >= this.options.sandLevelSize) || (testPtY >= this.options.sandLevelSize))
                //             continue;
                //         let shadePixLev = this.sandLevel[testPtX][testPtY];
                //         if (shadePixLev > ptSandLevel)
                //         {
                //             sandLevelShaded -=  (shadePixLev - ptSandLevel) / this.options.sandStartLevel / (k+2) / shadingRing.length / (k+1);
                //         }
                //     }
                // }
                // // See if shaded by sand in rings around this point
                // let shadingFactor = 0;
                // for (let k = 0; k < this.options.numShadingRings; k++) {
                //     let kernelRing = this.fullCircleKernelLists[k];
                //     for (let s = 0; s < kernelRing.length; s++) {
                //         // Check if this sand pixel shades
                //         let testPtX = kernelRing[s][0] + j + chgTLX;
                //         let testPtY = kernelRing[s][1] + i + chgTLY;
                //         if ((testPtX >= this.options.sandLevelSize) || (testPtY >= this.options.sandLevelSize))
                //             continue;
                //         let sandLev = this.sandLevel[testPtX][testPtY];
                //         if (sandLev > ptSandLevel)
                //         {
                //             shadingFactor +=  (sandLev - ptSandLevel) / this.options.sandStartLevel / (k+2) / kernelRing.length / (k+1);
                //         }
                //     }
                // }
                if (sandLevelShaded < 0)
                    sandLevelShaded = 0;
                if (sandLevelShaded >= this.options.maxSandLevel)
                    sandLevelShaded = this.options.maxSandLevel-0.01;
                // shadingFactor = 1 - shadingFactor;
                // let shadingFactor = this.sandLevel[j+chgTLX][i+chgTLY]/this.options.maxSandLevel;

                // Work outwards to see if 

                // fullSqData[k] = this.sandLevel[j][i];
                // fullSqData[k+1] = this.sandLevel[j][i];
                // fullSqData[k+2] = this.sandLevel[j][i];
                let pixVal = this.pixelLookup(sandLevelShaded);
                chgSq.data[k] = pixVal[0];
                chgSq.data[k+1] = pixVal[1];
                chgSq.data[k+2] = pixVal[2];
                chgSq.data[k+3] = pixVal[3];
                // if (fullSqData[k]>200 && fullSqData[k+1]>200 && fullSqData[k+2]>200)
                //     debugger;
                k+=4;
            }
        }
        ctx.putImageData(chgSq,chgTLX,chgTLY);
    }

    tallySand() {
        let sandTot = 0;
        let histBars = [];
        let sandBars = [];
        let maxLev = this.sandLevel[0][0];
        for (let i = 0; i < this.sandColours.length; i++) {
            histBars.push(0);
        }
        for (let i = 0; i < this.options.maxSandLevel; i++) {
            sandBars.push(0);
        }
        let sandLevelSize = this.options.sandLevelSize;
        for (let i = 0; i < sandLevelSize; i++) {
            for (let j = 0; j < sandLevelSize; j++) {
                // Debug
                if (maxLev < this.sandLevel[j][i])
                    maxLev = this.sandLevel[j][i];
                histBars[this.colourIndex(this.sandLevel[j][i])]++;
                sandBars[Math.floor(this.sandLevel[j][i])]++;
                sandTot += this.sandLevel[j][i];
            }
        }
        console.log("TotalSand " + sandTot + ", MaxLev " + maxLev + ", average " + sandTot / sandLevelSize / sandLevelSize + " TotalSandLoss " + this.totalSandLoss);

        // let barSum = 0;
        // for (let i = 0; i < histBars.length; i++) {
        //     console.log(i + " colr " + histBars[i]);
        //     barSum += histBars[i];
        // }
        // console.log("ColrSum = " + barSum);

        // let sandSum = 0;
        // for (let i = 0; i < sandBars.length; i++) {
        //     console.log(i + " sand " + sandBars[i]);
        //     sandSum += sandBars[i];
        // }
        // console.log("SandSum = " + barSum);

    }
    showSand() {
        let canvas = document.getElementById('table-canvas');
        let ctx = canvas.getContext('2d');
        let fullSq = ctx.getImageData(0, 0, 
                        this.options.sandLevelSize,
                        this.options.sandLevelSize);
        let sandLevelSize = this.options.sandLevelSize;
        let fullSqData = fullSq.data;
        let k = 0;
        for (let i = 0; i < sandLevelSize; i++)
        {
            for (let j = 0; j < sandLevelSize; j++)
            {
                // fullSqData[k] = this.sandLevel[j][i];
                // fullSqData[k+1] = this.sandLevel[j][i];
                // fullSqData[k+2] = this.sandLevel[j][i];
                let pixVal = this.pixelLookup(this.options.sandStartLevel);  // this.sandLevel[j][i]);
                fullSqData[k] = pixVal[0];
                fullSqData[k+1] = pixVal[1];
                fullSqData[k+2] = pixVal[2];
                fullSqData[k+3] = pixVal[3];
                // if (fullSqData[k]>200 && fullSqData[k+1]>200 && fullSqData[k+2]>200)
                //     debugger;
                k+=4;
            }
        }
        ctx.putImageData(fullSq,0,0);
    }
    getCanvasXYPos(canvas, varContext)
    {
        let wid = canvas.clientWidth - this.options.canvasBorder * 2;
        let hig = canvas.clientHeight - this.options.canvasBorder * 2;
        let xPos = ((varContext.x + varContext.originX)  / varContext.sizeX) * wid + this.options.canvasBorder;
        let yPos = canvas.clientHeight - (((varContext.y + varContext.originY)  / varContext.sizeY) * hig + this.options.canvasBorder);
        return [ xPos, yPos];
    }
    simStart(varContext)
    {
        let canvas = document.getElementById('table-canvas');
        const pointXY = this.getCanvasXYPos(canvas, varContext);
        this.options.ballPos[0] = pointXY[0];
        this.options.ballPos[1] = pointXY[1];
        // Start by moving sand all around the ball (in both forward and reverse direction)
        this.moveSand(pointXY[0], pointXY[1], 0);
        this.moveSand(pointXY[0]+1, pointXY[1], Math.PI);  
        // debugDump(300,300);
    }
    simNexPoint(varContext)
    {
        let canvas = document.getElementById('table-canvas');
        const pointXY = this.getCanvasXYPos(canvas, varContext);
        let pixelDist = Math.sqrt(Math.pow(pointXY[0]-this.options.ballPos[0], 2) + Math.pow(pointXY[1]-this.options.ballPos[1], 2));
        let drawSteps = Math.ceil(pixelDist+0.00001);
        if (drawSteps >= 500)
            drawSteps = 500;
        let stepX = (pointXY[0]-this.options.ballPos[0])/drawSteps;
        let stepY = (pointXY[1]-this.options.ballPos[1])/drawSteps;
        let ballAngle = Math.atan2(-stepY, stepX);
        for (let i = 0; i < drawSteps; i++)
        {
            let x = this.options.ballPos[0] + stepX * i;
            let y = this.options.ballPos[1] + stepY * i;
            this.moveSand(x, y, ballAngle, false);

        }
        this.options.ballPos[0] = pointXY[0];
        this.options.ballPos[1] = pointXY[1];
    }
    // debugIt()
    // {
    //     for (let i = 620; i < 680; i++)
    //     {
    //         console.log (this.sandLevel[i][400]);
    //     }
    // }
    // moveStep() {
    //  let canvas = document.getElementById('table-canvas');
    //     let canvasOff = canvas.getBoundingClientRect();

    //     // let ballX = this.options.sandLevelSize/2 + (this.options.sandLevelSize / 2 - 20 - this.evalExpr.r) * Math.sin(this.evalExpr.t);
    //     // let ballY = this.options.sandLevelSize/2 + (this.options.sandLevelSize / 2 - 20 - this.evalExpr.r) * Math.cos(this.evalExpr.t);
    //     // this.evalExpr.t += 0.01;
    //     // this.evalExpr.r += 0.01;
    //     // if (this.evalExpr.t > 600)
    //     //     this.evalExpr.t = 0;
    //     let t = this.evalExpr.t;

    //     let ballX = Math.sin(t/20) * (270 - t/10) * (1 + Math.sin(t*1.03)*0.05);
    //     let ballY = Math.cos(t/20) * (270 - t/10) * (1 + Math.sin(t*1.03)*0.05);
    //     this.evalExpr.t += 0.1;
    //     if (this.evalExpr.t > 100000)
    //         this.evalExpr.t = 0;
    //     ballX = this.options.sandLevelSize/2 + ballX;
    //     ballY = this.options.sandLevelSize/2 + ballY;

    //     let ballAngle = Math.atan2(this.options.ballPos[1] - ballY, ballX - this.options.ballPos[0]);
    //     this.options.ballPos[0] = ballX;
    //     this.options.ballPos[1] = ballY;
    //     this.moveSand(ballAngle);
    // }

    // animate() {
    //     for (let i = 0; i < 100; i++)
    //         this.moveStep();
    //     //this.showSand();
    //     requestAnimationFrame(() => this.animate());
    // }

    /**
    * http://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
    * SOURCE: http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
    * Converts an HSL color value to RGB. Conversion formula
    * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
    * Assumes h, s, and l are contained in the set [0, 1] and
    * returns r, g, and b in the set [0, 255].
    *
    * @param   Number  h       The hue
    * @param   Number  s       The saturation
    * @param   Number  l       The lightness
    * @return  Array           The RGB representation
    */
    hslToRgb(h, s, l){
        var r, g, b;

        if (s == 0) {
            r = g = b = l; // achromatic
        } else {
          var hue2rgb = function hue2rgb(p, q, t){
            if(t < 0) t += 1;
            if(t > 1) t -= 1;
            if(t < 1/6) return p + (q - p) * 6 * t;
            if(t < 1/2) return q;
            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          }

          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }

        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
      }
      
    /**
    * http://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
    * SOURCE: http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c  
    * Converts an RGB color value to HSL. Conversion formula
    * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
    * Assumes r, g, and b are contained in the set [0, 255] and
    * returns h, s, and l in the set [0, 1].
    *
    * @param   Number  r       The red color value
    * @param   Number  g       The green color value
    * @param   Number  b       The blue color value
    * @return  Array           The HSL representation
    */
    rgbToHsl(r, g, b){
        r /= 255, g /= 255, b /= 255;
        var max = Math.max(r, g, b), min = Math.min(r, g, b);
        var h, s, l = (max + min) / 2;

        if (max == min) {
            h = s = 0; // achromatic
        } else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch(max){
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }

        return [h, s, l];
    }
  
}


    function toRGBArrayStr(arr) {
        let pixStr = "";
        for (var i = 0; i < arr.length; i++)
            pixStr += ((pixStr.length === 0) ? "" : ",") + this.toRGBStr(arr[i]);
        return "[" + pixStr + "]";
    }

    function toRGBStr(pixData) {
         return "rgb(" + pixData[0] + "," + pixData[1] + "," + pixData[2] + "," + pixData[3] + ")";
    }
    // mousemove(event) {
        
    //     let canvasOff = this.canvas.getBoundingClientRect();

    //     let imgX = Math.floor(event.clientX - canvasOff.left);
    //     let imgY = Math.floor(event.clientY - canvasOff.top);

    //     let mouseX = event.clientX;
    //     let mouseY = event.clientY;

    //     var fullSq = this.ctx.getImageData(0, 0, 
    //                     this.options.sandLevelSize,
    //                     this.options.sandLevelSize);

    //     var tooltip = document.querySelector('#tooltip');

    //     let pixIdx = imgX * 4 + this.options.sandLevelSize * imgY * 4;
    //     tooltip.innerHTML = this.sandLevel[imgX][imgY].toFixed(2) + " (" + fullSq.data[pixIdx] + ", " + fullSq.data[pixIdx+1] + ", " + fullSq.data[pixIdx+2] + ")";
    //     tooltip.style.left = (mouseX-14) + "px";
    //     tooltip.style.top = (mouseY+12) + "px";
    // }

    // mouseover(event) {
    //     var canvas = document.querySelector('#tooltip');
    //     canvas.setAttribute("style","display:inline");
    // }

    // mouseout(event) {
    //     var canvas = document.querySelector('#tooltip');
    //     canvas.setAttribute("style","display:none");
    // }

    function getImagePixels(pixPos, sqSize) {
        var img = document.getElementById('sand');
        var memCanvas = document.createElement('canvas');
        memCanvas.width = img.width;
        memCanvas.height = img.height;
        memCanvas.getContext('2d').drawImage(img, 0, 0, img.width, img.height);
        var pixelData = memCanvas.getContext('2d').getImageData(pixPos[0]-Math.floor(sqSize/2), pixPos[1]-Math.floor(sqSize/2), sqSize, sqSize).data;
        console.log(pixPos[0] + ", " + pixPos[1] + " = ", pixelData);
        return pixelData;
    }

    // mouseclicksand(event) {

    //     var img = document.querySelector('#sand');
    //     let imgOff = img.getBoundingClientRect();

    //     let imgX = Math.floor(event.clientX - imgOff.left);
    //     let imgY = Math.floor(event.clientY - imgOff.top);

    //     console.log("ClickSand " + imgX + ", " + imgY);

    //     let pixData = this.getImagePixels([imgX, imgY], this.options.imgPixSqSize);
    //     let colrArry = [];
    //     for (var i = 0; i < this.options.imgPixSqSize * this.options.imgPixSqSize * 4; i+=4)
    //         colrArry.push([pixData[i], pixData[i+1], pixData[i+2], pixData[i+3]]);
    //     let pixDataStr = this.toRGBArrayStr(colrArry);
    //     let onePixStr = this.toRGBStr(colrArry[0]);
    //     // var fullSq = this.ctx.getImageData(0, 0,
    //     //                 this.options.sandLevelSize,
    //     //                 this.options.sandLevelSize);


    //     let elStr = $('.selected');
    //     let that = this;
    //     elStr.each(function() {
    //         $(this).val(pixDataStr);
    //         $(this).parent().parent().find(".colourPatchDiv").css('background-color', onePixStr);
    //         let cidx = parseInt($(this).parent().parent().find(".cidx").text());
    //         that.sandColours[cidx] = colrArry;
    //     });

    //     this.showSand();
    // }





    // animate() {
    //     for (let i = 0; i < 100; i++)
    //         this.moveStep();
    //     //this.showSand();
    //     requestAnimationFrame(() => this.animate());
    // }


// function handleMouseMove(event) {
//     var dot, eventDoc, doc, body, pageX, pageY;

//     event = event || window.event; // IE-ism

//     let x = event.pageX;
//     let y = event.pageY;

//     console.log(x + " " + y);
// }

function debugDump(inX,inY)
{
    console.log("")
    console.log("SandLevel base " + inX + ", " + inY)
    let tot = 0;
    let cnt = 0;
    for (let y = inY - 20; y < inY + 20; y++)
    {
        lineStr = "";
        for (let x = inX - 20; x < inX + 20; x++)
        {
            if (x < 0 || y < 0 || x >= sandTableSim.options.sandLevelSize || y >= sandTableSim.options.sandLevelSize)
                continue;
            lineStr += (Math.round(sandTableSim.sandLevel[x][y]*100)/100).toFixed(2) + " ";
            tot += sandTableSim.sandLevel[x][y];
            cnt++;
        }
        console.log(lineStr)
    }
    console.log("Tot " + tot + " cnt " + cnt + " avg " + tot/cnt);
}

function mouseclicktable(event)
{
    sandTableSim.tallySand();

    let img = document.querySelector('#table-canvas');
    let imgOff = img.getBoundingClientRect();

    let imgX = Math.floor(event.clientX - imgOff.left);
    let imgY = Math.floor(event.clientY - imgOff.top);

    // console.log("ClickTable " + imgX + ", " + imgY);

    // Dump sand level around point
    debugDump(imgX, imgY)

    // // let onePixStr = toRGBStr(colrArry[0]);
    // // var fullSq = this.ctx.getImageData(0, 0,
    // //                 this.options.sandLevelSize,
    // //                 this.options.sandLevelSize);

    // if (window.pageState.firstImgClick)
    // {
    //     window.pageState.clickPos = [imgX, imgY];
    // }
    // else
    // {
    //     let sandColours = [];
    //     let pixDataStr = "";
    //     xInc = (imgX - window.pageState.clickPos[0]) / sandTableSim.options.maxSandLevel;
    //     yInc = (imgY - window.pageState.clickPos[1]) / sandTableSim.options.maxSandLevel;
    //     for (let qq = 0; qq < sandTableSim.options.maxSandLevel; qq++)
    //     {
    //         let xx = window.pageState.clickPos[0] + xInc*qq;
    //         let yy = window.pageState.clickPos[1] + yInc*qq;
            
    //         let pixData = this.getImagePixels([xx, yy], window.pageState.imgPixSqSize);
    //         let colrArry = [];
    //         for (var i = 0; i < Math.pow(window.pageState.imgPixSqSize,2) * 4; i+=4)
    //             colrArry.push([pixData[i], pixData[i+1], pixData[i+2], pixData[i+3]]);
    //         pixDataStr += toRGBArrayStr(colrArry) + (qq != 9 ? "," : "") + "\n";
    //         sandColours.push(colrArry);
    //     }
    //     console.log(pixDataStr);
    //     sandTableSim.sandColours = sandColours;
    //     sandTableSim.initSand();
    //     sandTableSim.simStart({x:0, y:0, sizeX:sandTablePix,sizeY:sandTablePix, originX:sandTablePix/2, originY:sandTablePix/2});
    //     drawLine();
    // }
    // window.pageState.firstImgClick = !window.pageState.firstImgClick;
}


function mouseclickimg(event)
{
    let img = document.querySelector('#sand');
    let imgOff = img.getBoundingClientRect();

    let imgX = Math.floor(event.clientX - imgOff.left);
    let imgY = Math.floor(event.clientY - imgOff.top);

    console.log("ClickSand " + imgX + ", " + imgY);


    // let onePixStr = toRGBStr(colrArry[0]);
    // var fullSq = this.ctx.getImageData(0, 0,
    //                 this.options.sandLevelSize,
    //                 this.options.sandLevelSize);

    if (window.pageState.firstImgClick)
    {
        window.pageState.clickPos = [imgX, imgY];
    }
    else
    {
        let sandColours = [];
        let pixDataStr = "";
        xInc = (imgX - window.pageState.clickPos[0]) / sandTableSim.options.maxSandLevel;
        yInc = (imgY - window.pageState.clickPos[1]) / sandTableSim.options.maxSandLevel;
        for (let qq = 0; qq < sandTableSim.options.maxSandLevel; qq++)
        {
            let xx = window.pageState.clickPos[0] + xInc*qq;
            let yy = window.pageState.clickPos[1] + yInc*qq;
            
            let pixData = this.getImagePixels([xx, yy], window.pageState.imgPixSqSize);
            let colrArry = [];
            for (var i = 0; i < Math.pow(window.pageState.imgPixSqSize,2) * 4; i+=4)
                colrArry.push([pixData[i], pixData[i+1], pixData[i+2], pixData[i+3]]);
            pixDataStr += toRGBArrayStr(colrArry) + (qq != 9 ? "," : "") + "\n";
            sandColours.push(colrArry);
        }
        console.log(pixDataStr);
        sandTableSim.sandColours = sandColours;
        sandTableSim.initSand();
        sandTableSim.simStart({x:0, y:0, sizeX:sandTablePix,sizeY:sandTablePix, originX:sandTablePix/2, originY:sandTablePix/2});
        // drawLine();
    }
    window.pageState.firstImgClick = !window.pageState.firstImgClick;
}


function drawLine(x1,y1,x2,y2)
{
    let pts = Math.ceil(Math.max(Math.abs(x2-x1),Math.abs(y2-y1)));
    let xd = (x2-x1)/pts;
    let yd = (y2-y1)/pts;
    for (let i = 0; i < pts; i++)
    {
        sandTableSim.simNexPoint({x:x1+xd*i, y:y1+yd*i, sizeX:sandTablePix,sizeY:sandTablePix, originX:sandTablePix/2, originY:sandTablePix/2})
        // debugDump(sandTablePix/2,sandTablePix/2+i);
    }
}

function animate() {
    // return;
    for (let i = 0; i < 10; i++)
        moveStep();
    //this.showSand();
    requestAnimationFrame(animate);
}

function moveStep() {



    // let canvasOff = canvas.getBoundingClientRect();

    // let ballX = this.options.sandLevelSize/2 + (this.options.sandLevelSize / 2 - 20 - this.evalExpr.r) * Math.sin(this.evalExpr.t);
    // let ballY = this.options.sandLevelSize/2 + (this.options.sandLevelSize / 2 - 20 - this.evalExpr.r) * Math.cos(this.evalExpr.t);
    // this.evalExpr.t += 0.01;
    // this.evalExpr.r += 0.01;
    // if (this.evalExpr.t > 600)
    //     this.evalExpr.t = 0;

    let t = window.pageState.evalExpr.t;
    let ballX = Math.sin(t/20) * (270 - t/10) * (1 + Math.sin(t*1.03)*0.05);
    let ballY = Math.cos(t/20) * (270 - t/10) * (1 + Math.sin(t*1.03)*0.05);
    window.pageState.evalExpr.t += 0.2;
    if (window.pageState.evalExpr.t > 3000)
        window.pageState.evalExpr.t = 0;
    ballX = ballX;
    ballY = ballY;

    // let t = window.pageState.evalExpr.t;
    // let ballX = Math.sin(t/20) * (270 - t/10);
    // let ballY = Math.cos(t/20) * (270 - t/10);
    // window.pageState.evalExpr.t += 0.2;
    // if (window.pageState.evalExpr.t > 3000)
    //     window.pageState.evalExpr.t = 0;
    // ballX = ballX;
    // ballY = ballY;

    sandTableSim.simNexPoint({x:ballX, y:ballY, sizeX:sandTablePix,sizeY:sandTablePix, originX:sandTablePix/2, originY:sandTablePix/2})

    // let ballAngle = Math.atan2(this.options.ballPos[1] - ballY, ballX - this.options.ballPos[0]);
    // this.options.ballPos[0] = ballX;
    // this.options.ballPos[1] = ballY;
    // this.moveSand(ballAngle);
}

let sandTablePix = 600;
let canvas = document.getElementById("table-canvas");
let ctx = canvas.getContext('2d');
canvas.height = sandTablePix;
canvas.width = sandTablePix;
window.pageState = { evalExpr: {t:0}, firstImgClick: true, imgPixSqSize: 5 }
let sandTableSim = new SandTableSim(20, sandTablePix, 10);

sandTableSim.simStart({x:0, y:0, sizeX:sandTablePix,sizeY:sandTablePix, originX:sandTablePix/2, originY:sandTablePix/2});
// drawLine(0,0,100,0);
// drawLine(100,0,100,10);
// drawLine(100,10,0,10);
animate();
// drawLine();


</script>
</body>
</html>
